<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Agda.Utils.Function</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">Agda-2.6.5: A dependently typed functional programming language and proof assistant</span><ul class="links" id="page-menu"><li><a href="src/Agda.Utils.Function.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Agda.Utils.Function</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Iteration over Booleans.</a></li></ul></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:iterWhile">iterWhile</a> :: (b -&gt; <a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; (a -&gt; (b, a)) -&gt; a -&gt; [(b, a)]</li><li class="src short"><a href="#v:repeatWhile">repeatWhile</a> :: (a -&gt; (<a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>, a)) -&gt; a -&gt; a</li><li class="src short"><a href="#v:repeatWhileM">repeatWhileM</a> :: <a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>, a)) -&gt; a -&gt; m a</li><li class="src short"><a href="#v:trampolineWhile">trampolineWhile</a> :: (a -&gt; (<a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>, a)) -&gt; a -&gt; a</li><li class="src short"><a href="#v:trampolineWhileM">trampolineWhileM</a> :: <a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>, a)) -&gt; a -&gt; m a</li><li class="src short"><a href="#v:trampoline">trampoline</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> b a) -&gt; a -&gt; b</li><li class="src short"><a href="#v:trampolineM">trampolineM</a> :: <a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> b a)) -&gt; a -&gt; m b</li><li class="src short"><a href="#v:iterateUntil">iterateUntil</a> :: (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; (a -&gt; a) -&gt; a -&gt; a</li><li class="src short"><a href="#v:iterateUntilM">iterateUntilM</a> :: <a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; (a -&gt; m a) -&gt; a -&gt; m a</li><li class="src short"><a href="#v:iterate-39-">iterate'</a> :: <a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> i =&gt; i -&gt; (a -&gt; a) -&gt; a -&gt; a</li><li class="src short"><a href="#v:applyWhen">applyWhen</a> :: <a href="Agda-Utils-Boolean.html#t:IsBool" title="Agda.Utils.Boolean">IsBool</a> b =&gt; b -&gt; (a -&gt; a) -&gt; a -&gt; a</li><li class="src short"><a href="#v:applyUnless">applyUnless</a> :: <a href="Agda-Utils-Boolean.html#t:IsBool" title="Agda.Utils.Boolean">IsBool</a> b =&gt; b -&gt; (a -&gt; a) -&gt; a -&gt; a</li><li class="src short"><a href="#v:applyWhenM">applyWhenM</a> :: (<a href="Agda-Utils-Boolean.html#t:IsBool" title="Agda.Utils.Boolean">IsBool</a> b, <a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; (m a -&gt; m a) -&gt; m a -&gt; m a</li><li class="src short"><a href="#v:applyUnlessM">applyUnlessM</a> :: (<a href="Agda-Utils-Boolean.html#t:IsBool" title="Agda.Utils.Boolean">IsBool</a> b, <a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; (m a -&gt; m a) -&gt; m a -&gt; m a</li><li class="src short"><a href="#v:applyWhenJust">applyWhenJust</a> :: <a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b -&gt; (b -&gt; a -&gt; a) -&gt; a -&gt; a</li><li class="src short"><a href="#v:applyWhenNothing">applyWhenNothing</a> :: <a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b -&gt; (a -&gt; a) -&gt; a -&gt; a</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:iterWhile" class="def">iterWhile</a> :: (b -&gt; <a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; (a -&gt; (b, a)) -&gt; a -&gt; [(b, a)] <a href="src/Agda.Utils.Function.html#iterWhile" class="link">Source</a> <a href="#v:iterWhile" class="selflink">#</a></p><div class="doc"><p>Repeat a state transition <code>f :: a -&gt; (b, a)</code> with output <code>b</code>
   while condition <code>cond</code> on the output is true.
   Return all intermediate results and the final result
   where <code>cond</code> is <code>False</code>.</p><p>Postconditions (when it terminates):
   <code>fst (last (iterWhile cond f a)) == False</code>.
   <code>all fst (init (interWhile cond f a))</code>.</p></div></div><div class="top"><p class="src"><a id="v:repeatWhile" class="def">repeatWhile</a> :: (a -&gt; (<a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>, a)) -&gt; a -&gt; a <a href="src/Agda.Utils.Function.html#repeatWhile" class="link">Source</a> <a href="#v:repeatWhile" class="selflink">#</a></p><div class="doc"><p>Repeat something while a condition on some state is true.
   Return the last state (including the changes of the last
   transition, even if the condition became false then).</p></div></div><div class="top"><p class="src"><a id="v:repeatWhileM" class="def">repeatWhileM</a> :: <a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>, a)) -&gt; a -&gt; m a <a href="src/Agda.Utils.Function.html#repeatWhileM" class="link">Source</a> <a href="#v:repeatWhileM" class="selflink">#</a></p><div class="doc"><p>Monadic version of <code><a href="Agda-Utils-Function.html#v:repeatWhile" title="Agda.Utils.Function">repeatWhile</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:trampolineWhile" class="def">trampolineWhile</a> :: (a -&gt; (<a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>, a)) -&gt; a -&gt; a <a href="src/Agda.Utils.Function.html#trampolineWhile" class="link">Source</a> <a href="#v:trampolineWhile" class="selflink">#</a></p><div class="doc"><p>A version of the trampoline function.</p><p>The usual function iterates <code>f :: a -&gt; Maybe a</code> as long
   as <code>Just{}</code> is returned, and returns the last value of <code>a</code>
   upon <code>Nothing</code>.</p><p><code>usualTrampoline f = trampolineWhile $  a -&gt; maybe (False,a) (True,) (f a)</code>.</p><p><code>trampolineWhile</code> is very similar to <code>repeatWhile</code>, only that
   it discards the state on which the condition went <code>False</code>,
   and returns the last state on which the condition was <code>True</code>.</p></div></div><div class="top"><p class="src"><a id="v:trampolineWhileM" class="def">trampolineWhileM</a> :: <a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>, a)) -&gt; a -&gt; m a <a href="src/Agda.Utils.Function.html#trampolineWhileM" class="link">Source</a> <a href="#v:trampolineWhileM" class="selflink">#</a></p><div class="doc"><p>Monadic version of <code><a href="Agda-Utils-Function.html#v:trampolineWhile" title="Agda.Utils.Function">trampolineWhile</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:trampoline" class="def">trampoline</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> b a) -&gt; a -&gt; b <a href="src/Agda.Utils.Function.html#trampoline" class="link">Source</a> <a href="#v:trampoline" class="selflink">#</a></p><div class="doc"><p>More general trampoline, which allows some final computation
   from iteration state <code>a</code> into result type <code>b</code>.</p></div></div><div class="top"><p class="src"><a id="v:trampolineM" class="def">trampolineM</a> :: <a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> b a)) -&gt; a -&gt; m b <a href="src/Agda.Utils.Function.html#trampolineM" class="link">Source</a> <a href="#v:trampolineM" class="selflink">#</a></p><div class="doc"><p>Monadic version of <code><a href="Agda-Utils-Function.html#v:trampoline" title="Agda.Utils.Function">trampoline</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:iterateUntil" class="def">iterateUntil</a> :: (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; (a -&gt; a) -&gt; a -&gt; a <a href="src/Agda.Utils.Function.html#iterateUntil" class="link">Source</a> <a href="#v:iterateUntil" class="selflink">#</a></p><div class="doc"><p>Iteration to fixed-point.</p><p><code>iterateUntil r f a0</code> iterates endofunction <code>f</code>, starting with <code>a0</code>,
   until <code>r</code> relates its result to its input, i.e., <code>f a <code>r</code> a</code>.</p><p>This is the generic pattern behind saturation algorithms.</p><p>If <code>f</code> is monotone with regard to <code>r</code>,
   meaning <code>a <code>r</code> b</code> implies <code>f a <code>r</code> f b</code>,
   and <code>f</code>-chains starting with <code>a0</code> are finite
   then iteration is guaranteed to terminate.</p><p>A typical instance will work on sets, and <code>r</code> could be set inclusion,
   and <code>a0</code> the empty set, and <code>f</code> the step function of a saturation algorithm.</p></div></div><div class="top"><p class="src"><a id="v:iterateUntilM" class="def">iterateUntilM</a> :: <a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; (a -&gt; m a) -&gt; a -&gt; m a <a href="src/Agda.Utils.Function.html#iterateUntilM" class="link">Source</a> <a href="#v:iterateUntilM" class="selflink">#</a></p><div class="doc"><p>Monadic version of <code><a href="Agda-Utils-Function.html#v:iterateUntil" title="Agda.Utils.Function">iterateUntil</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:iterate-39-" class="def">iterate'</a> :: <a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> i =&gt; i -&gt; (a -&gt; a) -&gt; a -&gt; a <a href="src/Agda.Utils.Function.html#iterate%27" class="link">Source</a> <a href="#v:iterate-39-" class="selflink">#</a></p><div class="doc"><p><code><code><a href="Agda-Utils-Function.html#v:iterate-39-" title="Agda.Utils.Function">iterate'</a></code> n f x</code> applies <code>f</code> to <code>x</code> <code>n</code> times and returns the
 result.</p><p>The applications are calculated strictly.</p></div></div><a href="#g:1" id="g:1"><h1>Iteration over Booleans.</h1></a><div class="top"><p class="src"><a id="v:applyWhen" class="def">applyWhen</a> :: <a href="Agda-Utils-Boolean.html#t:IsBool" title="Agda.Utils.Boolean">IsBool</a> b =&gt; b -&gt; (a -&gt; a) -&gt; a -&gt; a <a href="src/Agda.Utils.Function.html#applyWhen" class="link">Source</a> <a href="#v:applyWhen" class="selflink">#</a></p><div class="doc"><p><code>applyWhen b f a</code> applies <code>f</code> to <code>a</code> when <code>b</code>.</p></div></div><div class="top"><p class="src"><a id="v:applyUnless" class="def">applyUnless</a> :: <a href="Agda-Utils-Boolean.html#t:IsBool" title="Agda.Utils.Boolean">IsBool</a> b =&gt; b -&gt; (a -&gt; a) -&gt; a -&gt; a <a href="src/Agda.Utils.Function.html#applyUnless" class="link">Source</a> <a href="#v:applyUnless" class="selflink">#</a></p><div class="doc"><p><code>applyUnless b f a</code> applies <code>f</code> to <code>a</code> unless <code>b</code>.</p></div></div><div class="top"><p class="src"><a id="v:applyWhenM" class="def">applyWhenM</a> :: (<a href="Agda-Utils-Boolean.html#t:IsBool" title="Agda.Utils.Boolean">IsBool</a> b, <a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; (m a -&gt; m a) -&gt; m a -&gt; m a <a href="src/Agda.Utils.Function.html#applyWhenM" class="link">Source</a> <a href="#v:applyWhenM" class="selflink">#</a></p><div class="doc"><p>Monadic version of <code>applyWhen</code></p></div></div><div class="top"><p class="src"><a id="v:applyUnlessM" class="def">applyUnlessM</a> :: (<a href="Agda-Utils-Boolean.html#t:IsBool" title="Agda.Utils.Boolean">IsBool</a> b, <a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; (m a -&gt; m a) -&gt; m a -&gt; m a <a href="src/Agda.Utils.Function.html#applyUnlessM" class="link">Source</a> <a href="#v:applyUnlessM" class="selflink">#</a></p><div class="doc"><p>Monadic version of <code>applyUnless</code></p></div></div><div class="top"><p class="src"><a id="v:applyWhenJust" class="def">applyWhenJust</a> :: <a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b -&gt; (b -&gt; a -&gt; a) -&gt; a -&gt; a <a href="src/Agda.Utils.Function.html#applyWhenJust" class="link">Source</a> <a href="#v:applyWhenJust" class="selflink">#</a></p><div class="doc"><p><code><a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a></code> version of <code><a href="Agda-Utils-Function.html#v:applyWhen" title="Agda.Utils.Function">applyWhen</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:applyWhenNothing" class="def">applyWhenNothing</a> :: <a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b -&gt; (a -&gt; a) -&gt; a -&gt; a <a href="src/Agda.Utils.Function.html#applyWhenNothing" class="link">Source</a> <a href="#v:applyWhenNothing" class="selflink">#</a></p><div class="doc"><p><code><a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a></code> version of <code><a href="Agda-Utils-Function.html#v:applyUnless" title="Agda.Utils.Function">applyUnless</a></code>.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.30.0</p></div></body></html>