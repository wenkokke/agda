<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE NondecreasingIndentation #-}</span><span>
</span><span id="line-2"></span><span>
</span><span id="line-3"></span><span class="hs-comment">-- | Pattern matcher used in the reducer for clauses that</span><span>
</span><span id="line-4"></span><span class="hs-comment">--   have not been compiled to case trees yet.</span><span>
</span><span id="line-5"></span><span>
</span><span id="line-6"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Agda.TypeChecking.Patterns.Match</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-7"></span><span>
</span><span id="line-8"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Prelude</span></span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">null</span></span><span class="hs-special">)</span><span>
</span><span id="line-9"></span><span>
</span><span id="line-10"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad</span></span><span>
</span><span id="line-11"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.IntMap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">IntMap</span></span><span class="hs-special">)</span><span>
</span><span id="line-12"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.IntMap</span></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">IntMap</span></span><span>
</span><span id="line-13"></span><span>
</span><span id="line-14"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.Syntax.Common.html"><span class="hs-identifier">Agda.Syntax.Common</span></a></span><span>
</span><span id="line-15"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html"><span class="hs-identifier">Agda.Syntax.Internal</span></a></span><span>
</span><span id="line-16"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.Pattern.html"><span class="hs-identifier">Agda.Syntax.Internal.Pattern</span></a></span><span>
</span><span id="line-17"></span><span>
</span><span id="line-18"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Reduce.html"><span class="hs-identifier">Agda.TypeChecking.Reduce</span></a></span><span>
</span><span id="line-19"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Reduce.Monad.html"><span class="hs-identifier">Agda.TypeChecking.Reduce.Monad</span></a></span><span>
</span><span id="line-20"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Substitute.html"><span class="hs-identifier">Agda.TypeChecking.Substitute</span></a></span><span>
</span><span id="line-21"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Monad.html"><span class="hs-identifier">Agda.TypeChecking.Monad</span></a></span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Monad.Builtin.html#constructorForm"><span class="hs-identifier">constructorForm</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-22"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Monad.Builtin.html"><span class="hs-identifier">Agda.TypeChecking.Monad.Builtin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Monad.Builtin.html#getName%27"><span class="hs-identifier">getName'</span></a></span><span class="hs-special">,</span><span class="annot"><a href="Agda.Syntax.Builtin.html#builtinHComp"><span class="hs-identifier">builtinHComp</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.Syntax.Builtin.html#builtinConId"><span class="hs-identifier">builtinConId</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-23"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Pretty.html"><span class="hs-identifier">Agda.TypeChecking.Pretty</span></a></span><span>
</span><span id="line-24"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Records.html"><span class="hs-identifier">Agda.TypeChecking.Records</span></a></span><span>
</span><span id="line-25"></span><span>
</span><span id="line-26"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.Utils.Empty.html"><span class="hs-identifier">Agda.Utils.Empty</span></a></span><span>
</span><span id="line-27"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.Utils.Functor.html"><span class="hs-identifier">Agda.Utils.Functor</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Utils.Functor.html#for"><span class="hs-identifier">for</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-operator">($&gt;)</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-operator">(&lt;&amp;&gt;)</span></span><span class="hs-special">)</span><span>
</span><span id="line-28"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.Utils.Maybe.html"><span class="hs-identifier">Agda.Utils.Maybe</span></a></span><span>
</span><span id="line-29"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.Utils.Null.html"><span class="hs-identifier">Agda.Utils.Null</span></a></span><span>
</span><span id="line-30"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.Utils.Singleton.html"><span class="hs-identifier">Agda.Utils.Singleton</span></a></span><span>
</span><span id="line-31"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.Utils.Size.html"><span class="hs-identifier">Agda.Utils.Size</span></a></span><span>
</span><span id="line-32"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.Utils.Tuple.html"><span class="hs-identifier">Agda.Utils.Tuple</span></a></span><span>
</span><span id="line-33"></span><span>
</span><span id="line-34"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.Utils.Impossible.html"><span class="hs-identifier">Agda.Utils.Impossible</span></a></span><span>
</span><span id="line-35"></span><span>
</span><span id="line-36"></span><span class="hs-comment">-- | If matching is inconclusive (@DontKnow@) we want to know whether</span><span>
</span><span id="line-37"></span><span class="hs-comment">--   it is due to a particular meta variable.</span><span>
</span><span id="line-38"></span><span class="hs-keyword">data</span><span> </span><span id="Match"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-identifier hs-var">Match</span></a></span></span><span> </span><span id="local-6989586621681495366"><span class="annot"><a href="#local-6989586621681495366"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Yes"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Yes"><span class="hs-identifier hs-var">Yes</span></a></span></span><span> </span><span class="annot"><a href="Agda.TypeChecking.Monad.Base.html#Simplification"><span class="hs-identifier hs-type">Simplification</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">IntMap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681495366"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-39"></span><span>             </span><span class="hs-glyph">|</span><span> </span><span id="No"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span></span><span>
</span><span id="line-40"></span><span>             </span><span class="hs-glyph">|</span><span> </span><span id="DontKnow"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#DontKnow"><span class="hs-identifier hs-var">DontKnow</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#Blocked"><span class="hs-identifier hs-type">Blocked</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-41"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span id="local-6989586621681495631"><span id="local-6989586621681495637"><span class="annot"><span class="annottext">(forall a b. (a -&gt; b) -&gt; Match a -&gt; Match b)
-&gt; (forall a b. a -&gt; Match b -&gt; Match a) -&gt; Functor Match
forall a b. a -&gt; Match b -&gt; Match a
forall a b. (a -&gt; b) -&gt; Match a -&gt; Match b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
$cfmap :: forall a b. (a -&gt; b) -&gt; Match a -&gt; Match b
fmap :: forall a b. (a -&gt; b) -&gt; Match a -&gt; Match b
$c&lt;$ :: forall a b. a -&gt; Match b -&gt; Match a
&lt;$ :: forall a b. a -&gt; Match b -&gt; Match a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span>
</span><span id="line-42"></span><span>
</span><span id="line-43"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621681495363"><span class="annot"><a href="Agda.Utils.Null.html#Null"><span class="hs-identifier hs-type">Null</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681495363"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-44"></span><span>  </span><span id="local-6989586621681495650"><span class="annot"><span class="annottext">empty :: Match a
</span><a href="#local-6989586621681495650"><span class="hs-identifier hs-var hs-var hs-var hs-var">empty</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Simplification -&gt; IntMap (Arg a) -&gt; Match a
forall a. Simplification -&gt; IntMap (Arg a) -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#Yes"><span class="hs-identifier hs-var">Yes</span></a></span><span> </span><span class="annot"><span class="annottext">Simplification
forall a. Null a =&gt; a
</span><a href="Agda.Utils.Null.html#empty"><span class="hs-identifier hs-var">empty</span></a></span><span> </span><span class="annot"><span class="annottext">IntMap (Arg a)
forall a. Null a =&gt; a
</span><a href="Agda.Utils.Null.html#empty"><span class="hs-identifier hs-var">empty</span></a></span><span>
</span><span id="line-45"></span><span>  </span><span id="local-6989586621681495654"><span class="annot"><span class="annottext">null :: Match a -&gt; Bool
</span><a href="#local-6989586621681495654"><span class="hs-identifier hs-var hs-var hs-var hs-var">null</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Yes"><span class="hs-identifier hs-type">Yes</span></a></span><span> </span><span id="local-6989586621681495656"><span class="annot"><span class="annottext">Simplification
</span><a href="#local-6989586621681495656"><span class="hs-identifier hs-var">simpl</span></a></span></span><span> </span><span id="local-6989586621681495657"><span class="annot"><span class="annottext">IntMap (Arg a)
</span><a href="#local-6989586621681495657"><span class="hs-keyword hs-var">as</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Simplification -&gt; Bool
forall a. Null a =&gt; a -&gt; Bool
</span><a href="Agda.Utils.Null.html#null"><span class="hs-identifier hs-var">null</span></a></span><span> </span><span class="annot"><span class="annottext">Simplification
</span><a href="#local-6989586621681495656"><span class="hs-identifier hs-var">simpl</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">IntMap (Arg a) -&gt; Bool
forall a. Null a =&gt; a -&gt; Bool
</span><a href="Agda.Utils.Null.html#null"><span class="hs-identifier hs-var">null</span></a></span><span> </span><span class="annot"><span class="annottext">IntMap (Arg a)
</span><a href="#local-6989586621681495657"><span class="hs-keyword hs-var">as</span></a></span><span>
</span><span id="line-46"></span><span>  </span><span class="annot"><a href="Agda.Utils.Null.html#null"><span class="hs-identifier hs-var">null</span></a></span><span> </span><span class="annot"><span class="annottext">Match a
</span><span class="hs-identifier">_</span></span><span>              </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-47"></span><span>
</span><span id="line-48"></span><span id="local-6989586621681495368"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#matchedArgs"><span class="hs-identifier hs-type">matchedArgs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.Utils.Empty.html#Empty"><span class="hs-identifier hs-type">Empty</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IntMap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681495368"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681495368"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-49"></span><span id="matchedArgs"><span class="annot"><span class="annottext">matchedArgs :: forall a. Empty -&gt; Int -&gt; IntMap (Arg a) -&gt; [Arg a]
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchedArgs"><span class="hs-identifier hs-var hs-var">matchedArgs</span></a></span></span><span> </span><span id="local-6989586621681495660"><span class="annot"><span class="annottext">Empty
</span><a href="#local-6989586621681495660"><span class="hs-identifier hs-var">err</span></a></span></span><span> </span><span id="local-6989586621681495661"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621681495661"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621681495662"><span class="annot"><span class="annottext">IntMap (Arg a)
</span><a href="#local-6989586621681495662"><span class="hs-identifier hs-var">vs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Maybe (Arg a) -&gt; Arg a) -&gt; [Maybe (Arg a)] -&gt; [Arg a]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Arg a -&gt; Maybe (Arg a) -&gt; Arg a
forall a. a -&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Empty -&gt; Arg a
forall a. Empty -&gt; a
</span><a href="Agda.Utils.Empty.html#absurd"><span class="hs-identifier hs-var">absurd</span></a></span><span> </span><span class="annot"><span class="annottext">Empty
</span><a href="#local-6989586621681495660"><span class="hs-identifier hs-var">err</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">([Maybe (Arg a)] -&gt; [Arg a]) -&gt; [Maybe (Arg a)] -&gt; [Arg a]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; IntMap (Arg a) -&gt; [Maybe (Arg a)]
forall a. Int -&gt; IntMap (Arg a) -&gt; [Maybe (Arg a)]
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchedArgs%27"><span class="hs-identifier hs-var">matchedArgs'</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621681495661"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">IntMap (Arg a)
</span><a href="#local-6989586621681495662"><span class="hs-identifier hs-var">vs</span></a></span><span>
</span><span id="line-50"></span><span>
</span><span id="line-51"></span><span id="local-6989586621681495378"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#matchedArgs%27"><span class="hs-identifier hs-type">matchedArgs'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IntMap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681495378"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681495378"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span></span><span>
</span><span id="line-52"></span><span id="matchedArgs%27"><span class="annot"><span class="annottext">matchedArgs' :: forall a. Int -&gt; IntMap (Arg a) -&gt; [Maybe (Arg a)]
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchedArgs%27"><span class="hs-identifier hs-var hs-var">matchedArgs'</span></a></span></span><span> </span><span id="local-6989586621681495672"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621681495672"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621681495673"><span class="annot"><span class="annottext">IntMap (Arg a)
</span><a href="#local-6989586621681495673"><span class="hs-identifier hs-var">vs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Int -&gt; Maybe (Arg a)) -&gt; [Int] -&gt; [Maybe (Arg a)]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Maybe (Arg a)
</span><a href="#local-6989586621681495674"><span class="hs-identifier hs-var">get</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span class="hs-glyph">..</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621681495672"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">]</span><span>
</span><span id="line-53"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-54"></span><span>    </span><span id="local-6989586621681495674"><span class="annot"><span class="annottext">get :: Int -&gt; Maybe (Arg a)
</span><a href="#local-6989586621681495674"><span class="hs-identifier hs-var hs-var">get</span></a></span></span><span> </span><span id="local-6989586621681495675"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621681495675"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; IntMap (Arg a) -&gt; Maybe (Arg a)
forall a. Int -&gt; IntMap a -&gt; Maybe a
</span><span class="hs-identifier hs-var">IntMap.lookup</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621681495675"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">IntMap (Arg a)
</span><a href="#local-6989586621681495673"><span class="hs-identifier hs-var">vs</span></a></span><span>
</span><span id="line-55"></span><span>
</span><span id="line-56"></span><span class="annot"><span class="hs-comment">-- | Builds a proper substitution from an IntMap produced by match(Co)patterns</span></span><span>
</span><span id="line-57"></span><span id="local-6989586621681495382"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#buildSubstitution"><span class="hs-identifier hs-type">buildSubstitution</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Substitute.DeBruijn.html#DeBruijn"><span class="hs-identifier hs-type">DeBruijn</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681495382"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-58"></span><span>                  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Agda.Utils.Impossible.html#Impossible"><span class="hs-identifier hs-type">Impossible</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IntMap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681495382"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Substitution%27"><span class="hs-identifier hs-type">Substitution'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681495382"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-59"></span><span id="buildSubstitution"><span class="annot"><span class="annottext">buildSubstitution :: forall a.
DeBruijn a =&gt;
Impossible -&gt; Int -&gt; IntMap (Arg a) -&gt; Substitution' a
</span><a href="Agda.TypeChecking.Patterns.Match.html#buildSubstitution"><span class="hs-identifier hs-var hs-var">buildSubstitution</span></a></span></span><span> </span><span id="local-6989586621681495682"><span class="annot"><span class="annottext">Impossible
</span><a href="#local-6989586621681495682"><span class="hs-identifier hs-var">err</span></a></span></span><span> </span><span id="local-6989586621681495683"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621681495683"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621681495684"><span class="annot"><span class="annottext">IntMap (Arg a)
</span><a href="#local-6989586621681495684"><span class="hs-identifier hs-var">vs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Maybe (Arg a) -&gt; Substitution' a -&gt; Substitution' a)
-&gt; Substitution' a -&gt; [Maybe (Arg a)] -&gt; Substitution' a
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Arg a) -&gt; Substitution' a -&gt; Substitution' a
</span><a href="#local-6989586621681495686"><span class="hs-identifier hs-var">cons</span></a></span><span> </span><span class="annot"><span class="annottext">Substitution' a
forall a. Substitution' a
</span><a href="Agda.TypeChecking.Substitute.Class.html#idS"><span class="hs-identifier hs-var">idS</span></a></span><span> </span><span class="annot"><span class="annottext">([Maybe (Arg a)] -&gt; Substitution' a)
-&gt; [Maybe (Arg a)] -&gt; Substitution' a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; IntMap (Arg a) -&gt; [Maybe (Arg a)]
forall a. Int -&gt; IntMap (Arg a) -&gt; [Maybe (Arg a)]
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchedArgs%27"><span class="hs-identifier hs-var">matchedArgs'</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621681495683"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">IntMap (Arg a)
</span><a href="#local-6989586621681495684"><span class="hs-identifier hs-var">vs</span></a></span><span>
</span><span id="line-60"></span><span>  </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621681495686"><span class="annot"><span class="annottext">cons :: Maybe (Arg a) -&gt; Substitution' a -&gt; Substitution' a
</span><a href="#local-6989586621681495686"><span class="hs-identifier hs-var hs-var">cons</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe (Arg a)
</span><span class="hs-identifier hs-var">Nothing</span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Impossible -&gt; Int -&gt; Substitution' a -&gt; Substitution' a
forall a. Impossible -&gt; Int -&gt; Substitution' a -&gt; Substitution' a
</span><a href="Agda.TypeChecking.Substitute.Class.html#strengthenS%27"><span class="hs-identifier hs-var">strengthenS'</span></a></span><span> </span><span class="annot"><span class="annottext">Impossible
</span><a href="#local-6989586621681495682"><span class="hs-identifier hs-var">err</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span>
</span><span id="line-61"></span><span>        </span><span class="annot"><a href="#local-6989586621681495686"><span class="hs-identifier hs-var">cons</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621681495689"><span class="annot"><span class="annottext">Arg a
</span><a href="#local-6989586621681495689"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; Substitution' a -&gt; Substitution' a
forall a. DeBruijn a =&gt; a -&gt; Substitution' a -&gt; Substitution' a
</span><a href="Agda.TypeChecking.Substitute.Class.html#consS"><span class="hs-identifier hs-var">consS</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Arg a -&gt; a
forall e. Arg e -&gt; e
</span><a href="Agda.Syntax.Common.html#unArg"><span class="hs-identifier hs-var">unArg</span></a></span><span> </span><span class="annot"><span class="annottext">Arg a
</span><a href="#local-6989586621681495689"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-62"></span><span>
</span><span id="line-63"></span><span>
</span><span id="line-64"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621681495398"><span id="local-6989586621681495694"><span id="local-6989586621681495698"><span class="annot"><span class="hs-identifier hs-type">Semigroup</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681495398"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-65"></span><span>    </span><span class="hs-comment">-- @NotBlocked (StuckOn e)@ means blocked by a variable.</span><span>
</span><span id="line-66"></span><span>    </span><span class="hs-comment">-- In this case, no instantiation of meta-variables will make progress.</span><span>
</span><span id="line-67"></span><span>    </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#DontKnow"><span class="hs-identifier hs-type">DontKnow</span></a></span><span> </span><span id="local-6989586621681495711"><span class="annot"><span class="annottext">Blocked ()
</span><a href="#local-6989586621681495711"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span id="local-6989586621681495712"><span class="annot"><span class="annottext">&lt;&gt; :: Match a -&gt; Match a -&gt; Match a
</span><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;&gt;</span></span></span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#DontKnow"><span class="hs-identifier hs-type">DontKnow</span></a></span><span> </span><span id="local-6989586621681495713"><span class="annot"><span class="annottext">Blocked ()
</span><a href="#local-6989586621681495713"><span class="hs-identifier hs-var">b'</span></a></span></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Blocked () -&gt; Match a
forall a. Blocked () -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#DontKnow"><span class="hs-identifier hs-var">DontKnow</span></a></span><span> </span><span class="annot"><span class="annottext">(Blocked () -&gt; Match a) -&gt; Blocked () -&gt; Match a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Blocked ()
</span><a href="#local-6989586621681495711"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">Blocked () -&gt; Blocked () -&gt; Blocked ()
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Blocked ()
</span><a href="#local-6989586621681495713"><span class="hs-identifier hs-var">b'</span></a></span><span>
</span><span id="line-68"></span><span>    </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#DontKnow"><span class="hs-identifier hs-type">DontKnow</span></a></span><span> </span><span id="local-6989586621681495714"><span class="annot"><span class="annottext">Blocked ()
</span><a href="#local-6989586621681495714"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="annot"><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Match a
</span><span class="hs-identifier">_</span></span><span>                </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Blocked () -&gt; Match a
forall a. Blocked () -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#DontKnow"><span class="hs-identifier hs-var">DontKnow</span></a></span><span> </span><span class="annot"><span class="annottext">Blocked ()
</span><a href="#local-6989586621681495714"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-69"></span><span>    </span><span class="annot"><span class="annottext">Match a
</span><span class="hs-identifier">_</span></span><span>          </span><span class="annot"><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#DontKnow"><span class="hs-identifier hs-type">DontKnow</span></a></span><span> </span><span id="local-6989586621681495715"><span class="annot"><span class="annottext">Blocked ()
</span><a href="#local-6989586621681495715"><span class="hs-identifier hs-var">m</span></a></span></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Blocked () -&gt; Match a
forall a. Blocked () -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#DontKnow"><span class="hs-identifier hs-var">DontKnow</span></a></span><span> </span><span class="annot"><span class="annottext">Blocked ()
</span><a href="#local-6989586621681495715"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-70"></span><span>    </span><span class="hs-comment">-- One could imagine DontKnow _ &lt;&gt; No = No, but would break the</span><span>
</span><span id="line-71"></span><span>    </span><span class="hs-comment">-- equivalence to case-trees (Issue 2964).</span><span>
</span><span id="line-72"></span><span>    </span><span class="annot"><span class="annottext">Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span><span>         </span><span class="annot"><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Match a
</span><span class="hs-identifier">_</span></span><span>                </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Match a
forall a. Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span><span>
</span><span id="line-73"></span><span>    </span><span class="annot"><span class="annottext">Match a
</span><span class="hs-identifier">_</span></span><span>          </span><span class="annot"><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span><span>               </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Match a
forall a. Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span><span>
</span><span id="line-74"></span><span>    </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Yes"><span class="hs-identifier hs-type">Yes</span></a></span><span> </span><span id="local-6989586621681495716"><span class="annot"><span class="annottext">Simplification
</span><a href="#local-6989586621681495716"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span id="local-6989586621681495717"><span class="annot"><span class="annottext">IntMap (Arg a)
</span><a href="#local-6989586621681495717"><span class="hs-identifier hs-var">us</span></a></span></span><span>   </span><span class="annot"><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Yes"><span class="hs-identifier hs-type">Yes</span></a></span><span> </span><span id="local-6989586621681495718"><span class="annot"><span class="annottext">Simplification
</span><a href="#local-6989586621681495718"><span class="hs-identifier hs-var">s'</span></a></span></span><span> </span><span id="local-6989586621681495719"><span class="annot"><span class="annottext">IntMap (Arg a)
</span><a href="#local-6989586621681495719"><span class="hs-identifier hs-var">vs</span></a></span></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Simplification -&gt; IntMap (Arg a) -&gt; Match a
forall a. Simplification -&gt; IntMap (Arg a) -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#Yes"><span class="hs-identifier hs-var">Yes</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Simplification
</span><a href="#local-6989586621681495716"><span class="hs-identifier hs-var">s</span></a></span><span> </span><span class="annot"><span class="annottext">Simplification -&gt; Simplification -&gt; Simplification
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Simplification
</span><a href="#local-6989586621681495718"><span class="hs-identifier hs-var">s'</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">IntMap (Arg a)
</span><a href="#local-6989586621681495717"><span class="hs-identifier hs-var">us</span></a></span><span> </span><span class="annot"><span class="annottext">IntMap (Arg a) -&gt; IntMap (Arg a) -&gt; IntMap (Arg a)
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">IntMap (Arg a)
</span><a href="#local-6989586621681495719"><span class="hs-identifier hs-var">vs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-75"></span><span>
</span><span id="line-76"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621681495406"><span id="local-6989586621681495725"><span class="annot"><span class="hs-identifier hs-type">Monoid</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681495406"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-77"></span><span>    </span><span id="local-6989586621681495730"><span class="annot"><span class="annottext">mempty :: Match a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">mempty</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Match a
forall a. Null a =&gt; a
</span><a href="Agda.Utils.Null.html#empty"><span class="hs-identifier hs-var">empty</span></a></span><span>
</span><span id="line-78"></span><span>    </span><span id="local-6989586621681495732"><span class="annot"><span class="annottext">mappend :: Match a -&gt; Match a -&gt; Match a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">mappend</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Match a -&gt; Match a -&gt; Match a
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">(&lt;&gt;)</span></span><span>
</span><span id="line-79"></span><span>
</span><span id="line-80"></span><span class="hs-comment">-- | Instead of 'zipWithM', we need to use this lazy version</span><span>
</span><span id="line-81"></span><span class="hs-comment">--   of combining pattern matching computations.</span><span>
</span><span id="line-82"></span><span>
</span><span id="line-83"></span><span class="hs-comment">-- Andreas, 2014-05-08, see Issue 1124:</span><span>
</span><span id="line-84"></span><span class="hs-comment">--</span><span>
</span><span id="line-85"></span><span class="hs-comment">-- Due to a bug in TypeChecking.Patterns.Match</span><span>
</span><span id="line-86"></span><span class="hs-comment">-- a failed match of (C n b) against (C O unit)</span><span>
</span><span id="line-87"></span><span class="hs-comment">-- turned into (C n unit).</span><span>
</span><span id="line-88"></span><span class="hs-comment">-- This was because all patterns were matched in</span><span>
</span><span id="line-89"></span><span class="hs-comment">-- parallel, and evaluations of successfull matches</span><span>
</span><span id="line-90"></span><span class="hs-comment">-- (and a record constructor like unit can always</span><span>
</span><span id="line-91"></span><span class="hs-comment">-- be successfully matched) were returned, leading</span><span>
</span><span id="line-92"></span><span class="hs-comment">-- to a reassembly of (C n b) as (C n unit) which is</span><span>
</span><span id="line-93"></span><span class="hs-comment">-- illtyped.</span><span>
</span><span id="line-94"></span><span>
</span><span id="line-95"></span><span class="hs-comment">-- Now patterns are matched left to right and</span><span>
</span><span id="line-96"></span><span class="hs-comment">-- upon failure, no further matching is performed.</span><span>
</span><span id="line-97"></span><span>
</span><span id="line-98"></span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#foldMatch"><span class="hs-identifier hs-type">foldMatch</span></a></span><span>
</span><span id="line-99"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681495409"><span class="annot"><a href="#local-6989586621681495409"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span id="local-6989586621681495407"><span class="annot"><a href="#local-6989586621681495407"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span id="local-6989586621681495410"><span class="annot"><a href="#local-6989586621681495410"><span class="hs-identifier hs-type">v</span></a></span></span><span> </span><span class="hs-operator">.</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Abstract.Name.html#IsProjP"><span class="hs-identifier hs-type">IsProjP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681495407"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#MonadMatch"><span class="hs-identifier hs-type">MonadMatch</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681495409"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-100"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621681495407"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681495410"><span class="hs-identifier hs-type">v</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681495409"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621681495410"><span class="hs-identifier hs-type">v</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-101"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621681495407"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621681495410"><span class="hs-identifier hs-type">v</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681495409"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621681495410"><span class="hs-identifier hs-type">v</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-102"></span><span id="foldMatch"><span class="annot"><span class="annottext">foldMatch :: forall (m :: * -&gt; *) p v.
(IsProjP p, MonadMatch m) =&gt;
(p -&gt; v -&gt; m (Match Term, v)) -&gt; [p] -&gt; [v] -&gt; m (Match Term, [v])
</span><a href="Agda.TypeChecking.Patterns.Match.html#foldMatch"><span class="hs-identifier hs-var hs-var">foldMatch</span></a></span></span><span> </span><span id="local-6989586621681495755"><span class="annot"><span class="annottext">p -&gt; v -&gt; m (Match Term, v)
</span><a href="#local-6989586621681495755"><span class="hs-identifier hs-var">match</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[p] -&gt; [v] -&gt; m (Match Term, [v])
</span><a href="#local-6989586621681495756"><span class="hs-identifier hs-var">loop</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-103"></span><span>  </span><span class="annot"><a href="#local-6989586621681495756"><span class="hs-identifier hs-type">loop</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621681495407"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621681495410"><span class="hs-identifier hs-type">v</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681495409"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621681495410"><span class="hs-identifier hs-type">v</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-104"></span><span>  </span><span id="local-6989586621681495756"><span class="annot"><span class="annottext">loop :: [p] -&gt; [v] -&gt; m (Match Term, [v])
</span><a href="#local-6989586621681495756"><span class="hs-identifier hs-var hs-var">loop</span></a></span></span><span> </span><span id="local-6989586621681495757"><span class="annot"><span class="annottext">[p]
</span><a href="#local-6989586621681495757"><span class="hs-identifier hs-var">ps0</span></a></span></span><span> </span><span id="local-6989586621681495758"><span class="annot"><span class="annottext">[v]
</span><a href="#local-6989586621681495758"><span class="hs-identifier hs-var">vs0</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-105"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[p]
</span><a href="#local-6989586621681495757"><span class="hs-identifier hs-var">ps0</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[v]
</span><a href="#local-6989586621681495758"><span class="hs-identifier hs-var">vs0</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-106"></span><span>      </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Match Term, [v]) -&gt; m (Match Term, [v])
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Match Term
forall a. Null a =&gt; a
</span><a href="Agda.Utils.Null.html#empty"><span class="hs-identifier hs-var">empty</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-107"></span><span>      </span><span class="hs-special">(</span><span id="local-6989586621681495759"><span class="annot"><span class="annottext">p
</span><a href="#local-6989586621681495759"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621681495760"><span class="annot"><span class="annottext">[p]
</span><a href="#local-6989586621681495760"><span class="hs-identifier hs-var">ps</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681495761"><span class="annot"><span class="annottext">v
</span><a href="#local-6989586621681495761"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621681495762"><span class="annot"><span class="annottext">[v]
</span><a href="#local-6989586621681495762"><span class="hs-identifier hs-var">vs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-108"></span><span>        </span><span class="hs-special">(</span><span id="local-6989586621681495763"><span class="annot"><span class="annottext">Match Term
</span><a href="#local-6989586621681495763"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681495764"><span class="annot"><span class="annottext">v
</span><a href="#local-6989586621681495764"><span class="hs-identifier hs-var">v'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">p -&gt; v -&gt; m (Match Term, v)
</span><a href="#local-6989586621681495755"><span class="hs-identifier hs-var">match</span></a></span><span> </span><span class="annot"><span class="annottext">p
</span><a href="#local-6989586621681495759"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">v
</span><a href="#local-6989586621681495761"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-109"></span><span>        </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Match Term
</span><a href="#local-6989586621681495763"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-110"></span><span>          </span><span class="annot"><span class="annottext">Match Term
</span><a href="Agda.TypeChecking.Patterns.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">p -&gt; Maybe (ProjOrigin, AmbiguousQName)
forall a. IsProjP a =&gt; a -&gt; Maybe (ProjOrigin, AmbiguousQName)
</span><a href="Agda.Syntax.Abstract.Name.html#isProjP"><span class="hs-identifier hs-var">isProjP</span></a></span><span> </span><span class="annot"><span class="annottext">p
</span><a href="#local-6989586621681495759"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Match Term, [v]) -&gt; m (Match Term, [v])
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Match Term
forall a. Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">v
</span><a href="#local-6989586621681495764"><span class="hs-identifier hs-var">v'</span></a></span><span> </span><span class="annot"><span class="annottext">v -&gt; [v] -&gt; [v]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[v]
</span><a href="#local-6989586621681495762"><span class="hs-identifier hs-var">vs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-111"></span><span>          </span><span class="annot"><span class="annottext">Match Term
</span><a href="Agda.TypeChecking.Patterns.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-112"></span><span>            </span><span class="hs-comment">-- Issue 2964: Even when the first pattern doesn't match we should</span><span>
</span><span id="line-113"></span><span>            </span><span class="hs-comment">-- continue to the next patterns (and potentially block on them)</span><span>
</span><span id="line-114"></span><span>            </span><span class="hs-comment">-- because the splitting order in the case tree may not be</span><span>
</span><span id="line-115"></span><span>            </span><span class="hs-comment">-- left-to-right.</span><span>
</span><span id="line-116"></span><span>            </span><span class="hs-special">(</span><span id="local-6989586621681495766"><span class="annot"><span class="annottext">Match Term
</span><a href="#local-6989586621681495766"><span class="hs-identifier hs-var">r'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681495767"><span class="annot"><span class="annottext">[v]
</span><a href="#local-6989586621681495767"><span class="hs-identifier hs-var">_vs'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[p] -&gt; [v] -&gt; m (Match Term, [v])
</span><a href="#local-6989586621681495756"><span class="hs-identifier hs-var">loop</span></a></span><span> </span><span class="annot"><span class="annottext">[p]
</span><a href="#local-6989586621681495760"><span class="hs-identifier hs-var">ps</span></a></span><span> </span><span class="annot"><span class="annottext">[v]
</span><a href="#local-6989586621681495762"><span class="hs-identifier hs-var">vs</span></a></span><span>
</span><span id="line-117"></span><span>            </span><span class="hs-comment">-- Issue 2968: do not use vs' here, because it might</span><span>
</span><span id="line-118"></span><span>            </span><span class="hs-comment">-- contain ill-typed terms due to eta-expansion at wrong</span><span>
</span><span id="line-119"></span><span>            </span><span class="hs-comment">-- type.</span><span>
</span><span id="line-120"></span><span>            </span><span class="annot"><span class="annottext">(Match Term, [v]) -&gt; m (Match Term, [v])
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Match Term
</span><a href="#local-6989586621681495763"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">Match Term -&gt; Match Term -&gt; Match Term
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Match Term
</span><a href="#local-6989586621681495766"><span class="hs-identifier hs-var">r'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">v
</span><a href="#local-6989586621681495764"><span class="hs-identifier hs-var">v'</span></a></span><span> </span><span class="annot"><span class="annottext">v -&gt; [v] -&gt; [v]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[v]
</span><a href="#local-6989586621681495762"><span class="hs-identifier hs-var">vs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-121"></span><span>          </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#DontKnow"><span class="hs-identifier hs-type">DontKnow</span></a></span><span> </span><span id="local-6989586621681495768"><span class="annot"><span class="annottext">Blocked ()
</span><a href="#local-6989586621681495768"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Match Term, [v]) -&gt; m (Match Term, [v])
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Blocked () -&gt; Match Term
forall a. Blocked () -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#DontKnow"><span class="hs-identifier hs-var">DontKnow</span></a></span><span> </span><span class="annot"><span class="annottext">Blocked ()
</span><a href="#local-6989586621681495768"><span class="hs-identifier hs-var">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">v
</span><a href="#local-6989586621681495764"><span class="hs-identifier hs-var">v'</span></a></span><span> </span><span class="annot"><span class="annottext">v -&gt; [v] -&gt; [v]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[v]
</span><a href="#local-6989586621681495762"><span class="hs-identifier hs-var">vs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-122"></span><span>          </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Yes"><span class="hs-identifier hs-type">Yes</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-123"></span><span>            </span><span class="hs-special">(</span><span id="local-6989586621681495769"><span class="annot"><span class="annottext">Match Term
</span><a href="#local-6989586621681495769"><span class="hs-identifier hs-var">r'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681495770"><span class="annot"><span class="annottext">[v]
</span><a href="#local-6989586621681495770"><span class="hs-identifier hs-var">vs'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[p] -&gt; [v] -&gt; m (Match Term, [v])
</span><a href="#local-6989586621681495756"><span class="hs-identifier hs-var">loop</span></a></span><span> </span><span class="annot"><span class="annottext">[p]
</span><a href="#local-6989586621681495760"><span class="hs-identifier hs-var">ps</span></a></span><span> </span><span class="annot"><span class="annottext">[v]
</span><a href="#local-6989586621681495762"><span class="hs-identifier hs-var">vs</span></a></span><span>
</span><span id="line-124"></span><span>            </span><span class="annot"><span class="annottext">(Match Term, [v]) -&gt; m (Match Term, [v])
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Match Term
</span><a href="#local-6989586621681495763"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">Match Term -&gt; Match Term -&gt; Match Term
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Match Term
</span><a href="#local-6989586621681495769"><span class="hs-identifier hs-var">r'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">v
</span><a href="#local-6989586621681495764"><span class="hs-identifier hs-var">v'</span></a></span><span> </span><span class="annot"><span class="annottext">v -&gt; [v] -&gt; [v]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[v]
</span><a href="#local-6989586621681495770"><span class="hs-identifier hs-var">vs'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-125"></span><span>      </span><span class="annot"><span class="annottext">([p], [v])
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match Term, [v])
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span>
</span><span id="line-126"></span><span>
</span><span id="line-127"></span><span>
</span><span id="line-128"></span><span class="hs-comment">-- TODO refactor matchPattern* to work with Elim instead.</span><span>
</span><span id="line-129"></span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#mergeElim"><span class="hs-identifier hs-type">mergeElim</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Elim"><span class="hs-identifier hs-type">Elim</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Elim"><span class="hs-identifier hs-type">Elim</span></a></span><span>
</span><span id="line-130"></span><span id="mergeElim"><span class="annot"><span class="annottext">mergeElim :: Elim -&gt; Arg Term -&gt; Elim
</span><a href="Agda.TypeChecking.Patterns.Match.html#mergeElim"><span class="hs-identifier hs-var hs-var">mergeElim</span></a></span></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.Elim.html#Apply"><span class="hs-identifier hs-type">Apply</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span id="local-6989586621681495774"><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621681495774"><span class="hs-identifier hs-var">arg</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Arg Term -&gt; Elim
forall a. Arg a -&gt; Elim' a
</span><a href="Agda.Syntax.Internal.Elim.html#Apply"><span class="hs-identifier hs-var">Apply</span></a></span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621681495774"><span class="hs-identifier hs-var">arg</span></a></span><span>
</span><span id="line-131"></span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#mergeElim"><span class="hs-identifier hs-var">mergeElim</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.Elim.html#IApply"><span class="hs-identifier hs-type">IApply</span></a></span><span> </span><span id="local-6989586621681495776"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621681495776"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621681495777"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621681495777"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621681495778"><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621681495778"><span class="hs-identifier hs-var">arg</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Term -&gt; Term -&gt; Term -&gt; Elim
forall a. a -&gt; a -&gt; a -&gt; Elim' a
</span><a href="Agda.Syntax.Internal.Elim.html#IApply"><span class="hs-identifier hs-var">IApply</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621681495776"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621681495777"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Arg Term -&gt; Term
forall e. Arg e -&gt; e
</span><a href="Agda.Syntax.Common.html#unArg"><span class="hs-identifier hs-var">unArg</span></a></span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621681495778"><span class="hs-identifier hs-var">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-132"></span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#mergeElim"><span class="hs-identifier hs-var">mergeElim</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.Elim.html#Proj"><span class="hs-identifier hs-type">Proj</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Elim
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span>
</span><span id="line-133"></span><span>
</span><span id="line-134"></span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#mergeElims"><span class="hs-identifier hs-type">mergeElims</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Internal.html#Elim"><span class="hs-identifier hs-type">Elim</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Internal.html#Elim"><span class="hs-identifier hs-type">Elim</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-135"></span><span id="mergeElims"><span class="annot"><span class="annottext">mergeElims :: [Elim] -&gt; [Arg Term] -&gt; [Elim]
</span><a href="Agda.TypeChecking.Patterns.Match.html#mergeElims"><span class="hs-identifier hs-var hs-var">mergeElims</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Elim -&gt; Arg Term -&gt; Elim) -&gt; [Elim] -&gt; [Arg Term] -&gt; [Elim]
forall a b c. (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]
</span><span class="hs-identifier hs-var">zipWith</span></span><span> </span><span class="annot"><span class="annottext">Elim -&gt; Arg Term -&gt; Elim
</span><a href="Agda.TypeChecking.Patterns.Match.html#mergeElim"><span class="hs-identifier hs-var">mergeElim</span></a></span><span>
</span><span id="line-136"></span><span>
</span><span id="line-137"></span><span class="hs-keyword">type</span><span> </span><span id="MonadMatch"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#MonadMatch"><span class="hs-identifier hs-var">MonadMatch</span></a></span></span><span> </span><span id="local-6989586621681495782"><span class="annot"><a href="#local-6989586621681495782"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Monad.Pure.html#PureTCM"><span class="hs-identifier hs-type">PureTCM</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681495782"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-138"></span><span>
</span><span id="line-139"></span><span class="hs-comment">-- | @matchCopatterns ps es@ matches spine @es@ against copattern spine @ps@.</span><span>
</span><span id="line-140"></span><span class="hs-comment">--</span><span>
</span><span id="line-141"></span><span class="hs-comment">--   Returns 'Yes' and a substitution for the pattern variables</span><span>
</span><span id="line-142"></span><span class="hs-comment">--   (in form of IntMap Term) if matching was successful.</span><span>
</span><span id="line-143"></span><span class="hs-comment">--</span><span>
</span><span id="line-144"></span><span class="hs-comment">--   Returns 'No' if there was a constructor or projection mismatch.</span><span>
</span><span id="line-145"></span><span class="hs-comment">--</span><span>
</span><span id="line-146"></span><span class="hs-comment">--   Returns 'DontKnow' if an argument could not be evaluated to</span><span>
</span><span id="line-147"></span><span class="hs-comment">--   constructor form because of a blocking meta variable.</span><span>
</span><span id="line-148"></span><span class="hs-comment">--</span><span>
</span><span id="line-149"></span><span class="hs-comment">--   In any case, also returns spine @es@ in reduced form</span><span>
</span><span id="line-150"></span><span class="hs-comment">--   (with all the weak head reductions performed that were necessary</span><span>
</span><span id="line-151"></span><span class="hs-comment">--   to come to a decision).</span><span>
</span><span id="line-152"></span><span id="local-6989586621681495432"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#matchCopatterns"><span class="hs-identifier hs-type">matchCopatterns</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#MonadMatch"><span class="hs-identifier hs-type">MonadMatch</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681495432"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-153"></span><span>                </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Common.html#NamedArg"><span class="hs-identifier hs-type">NamedArg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#DeBruijnPattern"><span class="hs-identifier hs-type">DeBruijnPattern</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-154"></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Internal.html#Elim"><span class="hs-identifier hs-type">Elim</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-155"></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681495432"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Internal.html#Elim"><span class="hs-identifier hs-type">Elim</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span></span><span>
</span><span id="line-156"></span><span id="matchCopatterns"><span class="annot"><span class="annottext">matchCopatterns :: forall (m :: * -&gt; *).
MonadMatch m =&gt;
[NamedArg DeBruijnPattern] -&gt; [Elim] -&gt; m (Match Term, [Elim])
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchCopatterns"><span class="hs-identifier hs-var hs-var">matchCopatterns</span></a></span></span><span> </span><span id="local-6989586621681495848"><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621681495848"><span class="hs-identifier hs-var">ps</span></a></span></span><span> </span><span id="local-6989586621681495849"><span class="annot"><span class="annottext">[Elim]
</span><a href="#local-6989586621681495849"><span class="hs-identifier hs-var">vs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-157"></span><span>  </span><span class="annot"><span class="annottext">VerboseKey
-&gt; Int
-&gt; TCMT IO Doc
-&gt; m (Match Term, [Elim])
-&gt; m (Match Term, [Elim])
forall (m :: * -&gt; *) a.
MonadDebug m =&gt;
VerboseKey -&gt; Int -&gt; TCMT IO Doc -&gt; m a -&gt; m a
</span><a href="Agda.TypeChecking.Monad.Debug.html#traceSDoc"><span class="hs-identifier hs-var">traceSDoc</span></a></span><span> </span><span class="annot"><span class="annottext">VerboseKey
</span><span class="hs-string">&quot;tc.match&quot;</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">50</span></span><span>
</span><span id="line-158"></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TCMT IO Doc] -&gt; TCMT IO Doc
forall (m :: * -&gt; *) (t :: * -&gt; *).
(Applicative m, Foldable t) =&gt;
t (m Doc) -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#vcat"><span class="hs-identifier hs-var">vcat</span></a></span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc
</span><span class="hs-string">&quot;matchCopatterns&quot;</span></span><span>
</span><span id="line-159"></span><span>          </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Int -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall (m :: * -&gt; *). Functor m =&gt; Int -&gt; m Doc -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#nest"><span class="hs-identifier hs-var">nest</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span> </span><span class="annot"><span class="annottext">(TCMT IO Doc -&gt; TCMT IO Doc) -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc
</span><span class="hs-string">&quot;ps =&quot;</span></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall (m :: * -&gt; *). Applicative m =&gt; m Doc -&gt; m Doc -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">[TCMT IO Doc] -&gt; TCMT IO Doc
forall (m :: * -&gt; *) (t :: * -&gt; *).
(Applicative m, Foldable t) =&gt;
t (m Doc) -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#fsep"><span class="hs-identifier hs-var">fsep</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TCMT IO Doc -&gt; [TCMT IO Doc] -&gt; [TCMT IO Doc]
forall (m :: * -&gt; *) (t :: * -&gt; *).
(Applicative m, Semigroup (m Doc), Foldable t) =&gt;
m Doc -&gt; t (m Doc) -&gt; [m Doc]
</span><a href="Agda.TypeChecking.Pretty.html#punctuate"><span class="hs-identifier hs-var">punctuate</span></a></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc
forall (m :: * -&gt; *). Applicative m =&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#comma"><span class="hs-identifier hs-var">comma</span></a></span><span> </span><span class="annot"><span class="annottext">([TCMT IO Doc] -&gt; [TCMT IO Doc]) -&gt; [TCMT IO Doc] -&gt; [TCMT IO Doc]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(NamedArg DeBruijnPattern -&gt; TCMT IO Doc)
-&gt; [NamedArg DeBruijnPattern] -&gt; [TCMT IO Doc]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DeBruijnPattern -&gt; TCMT IO Doc
forall a (m :: * -&gt; *). (PrettyTCM a, MonadPretty m) =&gt; a -&gt; m Doc
forall (m :: * -&gt; *). MonadPretty m =&gt; DeBruijnPattern -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#prettyTCM"><span class="hs-identifier hs-var">prettyTCM</span></a></span><span> </span><span class="annot"><span class="annottext">(DeBruijnPattern -&gt; TCMT IO Doc)
-&gt; (NamedArg DeBruijnPattern -&gt; DeBruijnPattern)
-&gt; NamedArg DeBruijnPattern
-&gt; TCMT IO Doc
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">NamedArg DeBruijnPattern -&gt; DeBruijnPattern
forall a. NamedArg a -&gt; a
</span><a href="Agda.Syntax.Common.html#namedArg"><span class="hs-identifier hs-var">namedArg</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621681495848"><span class="hs-identifier hs-var">ps</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-160"></span><span>          </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Int -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall (m :: * -&gt; *). Functor m =&gt; Int -&gt; m Doc -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#nest"><span class="hs-identifier hs-var">nest</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span> </span><span class="annot"><span class="annottext">(TCMT IO Doc -&gt; TCMT IO Doc) -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc
</span><span class="hs-string">&quot;vs =&quot;</span></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall (m :: * -&gt; *). Applicative m =&gt; m Doc -&gt; m Doc -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">[TCMT IO Doc] -&gt; TCMT IO Doc
forall (m :: * -&gt; *) (t :: * -&gt; *).
(Applicative m, Foldable t) =&gt;
t (m Doc) -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#fsep"><span class="hs-identifier hs-var">fsep</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TCMT IO Doc -&gt; [TCMT IO Doc] -&gt; [TCMT IO Doc]
forall (m :: * -&gt; *) (t :: * -&gt; *).
(Applicative m, Semigroup (m Doc), Foldable t) =&gt;
m Doc -&gt; t (m Doc) -&gt; [m Doc]
</span><a href="Agda.TypeChecking.Pretty.html#punctuate"><span class="hs-identifier hs-var">punctuate</span></a></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc
forall (m :: * -&gt; *). Applicative m =&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#comma"><span class="hs-identifier hs-var">comma</span></a></span><span> </span><span class="annot"><span class="annottext">([TCMT IO Doc] -&gt; [TCMT IO Doc]) -&gt; [TCMT IO Doc] -&gt; [TCMT IO Doc]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Elim -&gt; TCMT IO Doc) -&gt; [Elim] -&gt; [TCMT IO Doc]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Elim -&gt; TCMT IO Doc
forall a (m :: * -&gt; *). (PrettyTCM a, MonadPretty m) =&gt; a -&gt; m Doc
forall (m :: * -&gt; *). MonadPretty m =&gt; Elim -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#prettyTCM"><span class="hs-identifier hs-var">prettyTCM</span></a></span><span> </span><span class="annot"><span class="annottext">[Elim]
</span><a href="#local-6989586621681495849"><span class="hs-identifier hs-var">vs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-161"></span><span>          </span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(m (Match Term, [Elim]) -&gt; m (Match Term, [Elim]))
-&gt; m (Match Term, [Elim]) -&gt; m (Match Term, [Elim])
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-162"></span><span>  </span><span class="hs-comment">-- Buggy, see issue 1124:</span><span>
</span><span id="line-163"></span><span>  </span><span class="hs-comment">-- mapFst mconcat . unzip &lt;$&gt; zipWithM' (matchCopattern . namedArg) ps vs</span><span>
</span><span id="line-164"></span><span>  </span><span class="annot"><span class="annottext">(NamedArg DeBruijnPattern -&gt; Elim -&gt; m (Match Term, Elim))
-&gt; [NamedArg DeBruijnPattern] -&gt; [Elim] -&gt; m (Match Term, [Elim])
forall (m :: * -&gt; *) p v.
(IsProjP p, MonadMatch m) =&gt;
(p -&gt; v -&gt; m (Match Term, v)) -&gt; [p] -&gt; [v] -&gt; m (Match Term, [v])
</span><a href="Agda.TypeChecking.Patterns.Match.html#foldMatch"><span class="hs-identifier hs-var">foldMatch</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DeBruijnPattern -&gt; Elim -&gt; m (Match Term, Elim)
forall (m :: * -&gt; *).
MonadMatch m =&gt;
DeBruijnPattern -&gt; Elim -&gt; m (Match Term, Elim)
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchCopattern"><span class="hs-identifier hs-var">matchCopattern</span></a></span><span> </span><span class="annot"><span class="annottext">(DeBruijnPattern -&gt; Elim -&gt; m (Match Term, Elim))
-&gt; (NamedArg DeBruijnPattern -&gt; DeBruijnPattern)
-&gt; NamedArg DeBruijnPattern
-&gt; Elim
-&gt; m (Match Term, Elim)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">NamedArg DeBruijnPattern -&gt; DeBruijnPattern
forall a. NamedArg a -&gt; a
</span><a href="Agda.Syntax.Common.html#namedArg"><span class="hs-identifier hs-var">namedArg</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621681495848"><span class="hs-identifier hs-var">ps</span></a></span><span> </span><span class="annot"><span class="annottext">[Elim]
</span><a href="#local-6989586621681495849"><span class="hs-identifier hs-var">vs</span></a></span><span>
</span><span id="line-165"></span><span>
</span><span id="line-166"></span><span class="annot"><span class="hs-comment">-- | Match a single copattern.</span></span><span>
</span><span id="line-167"></span><span id="local-6989586621681495486"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#matchCopattern"><span class="hs-identifier hs-type">matchCopattern</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#MonadMatch"><span class="hs-identifier hs-type">MonadMatch</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681495486"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-168"></span><span>               </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#DeBruijnPattern"><span class="hs-identifier hs-type">DeBruijnPattern</span></a></span><span>
</span><span id="line-169"></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Elim"><span class="hs-identifier hs-type">Elim</span></a></span><span>
</span><span id="line-170"></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681495486"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Elim"><span class="hs-identifier hs-type">Elim</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-171"></span><span id="matchCopattern"><span class="annot"><span class="annottext">matchCopattern :: forall (m :: * -&gt; *).
MonadMatch m =&gt;
DeBruijnPattern -&gt; Elim -&gt; m (Match Term, Elim)
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchCopattern"><span class="hs-identifier hs-var hs-var">matchCopattern</span></a></span></span><span> </span><span id="local-6989586621681495889"><span class="annot"><span class="annottext">pat :: DeBruijnPattern
</span><a href="#local-6989586621681495889"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-glyph">@</span><span class="annot"><a href="Agda.Syntax.Internal.html#ProjP"><span class="hs-identifier hs-type">ProjP</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span id="local-6989586621681495891"><span class="annot"><span class="annottext">elim :: Elim
</span><a href="#local-6989586621681495891"><span class="hs-identifier hs-var">elim</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.Elim.html#Proj"><span class="hs-identifier hs-type">Proj</span></a></span><span> </span><span class="annot"><span class="annottext">ProjOrigin
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681495892"><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621681495892"><span class="hs-identifier hs-var">q</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-172"></span><span>  </span><span id="local-6989586621681495893"><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621681495893"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">DeBruijnPattern -&gt; m DeBruijnPattern
forall a (m :: * -&gt; *).
(NormaliseProjP a, HasConstInfo m) =&gt;
a -&gt; m a
forall (m :: * -&gt; *).
HasConstInfo m =&gt;
DeBruijnPattern -&gt; m DeBruijnPattern
</span><a href="Agda.TypeChecking.Records.html#normaliseProjP"><span class="hs-identifier hs-var">normaliseProjP</span></a></span><span> </span><span class="annot"><span class="annottext">DeBruijnPattern
</span><a href="#local-6989586621681495889"><span class="hs-identifier hs-var">pat</span></a></span><span> </span><span class="annot"><span class="annottext">m DeBruijnPattern -&gt; (DeBruijnPattern -&gt; QName) -&gt; m QName
forall (f :: * -&gt; *) a b. Functor f =&gt; f a -&gt; (a -&gt; b) -&gt; f b
</span><span class="hs-operator hs-var">&lt;&amp;&gt;</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-173"></span><span>         </span><span class="annot"><a href="Agda.Syntax.Internal.html#ProjP"><span class="hs-identifier hs-type">ProjP</span></a></span><span> </span><span class="annot"><span class="annottext">ProjOrigin
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681495895"><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621681495895"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621681495895"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-174"></span><span>         </span><span class="annot"><span class="annottext">DeBruijnPattern
</span><span class="hs-identifier">_</span></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">QName
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span>
</span><span id="line-175"></span><span>  </span><span id="local-6989586621681495896"><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621681495896"><span class="hs-identifier hs-var">q</span></a></span></span><span>       </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">QName -&gt; m QName
forall (m :: * -&gt; *). HasConstInfo m =&gt; QName -&gt; m QName
</span><a href="Agda.TypeChecking.Monad.Signature.html#getOriginalProjection"><span class="hs-identifier hs-var">getOriginalProjection</span></a></span><span> </span><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621681495892"><span class="hs-identifier hs-var">q</span></a></span><span>
</span><span id="line-176"></span><span>  </span><span class="annot"><span class="annottext">(Match Term, Elim) -&gt; m (Match Term, Elim)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">((Match Term, Elim) -&gt; m (Match Term, Elim))
-&gt; (Match Term, Elim) -&gt; m (Match Term, Elim)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621681495893"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">QName -&gt; QName -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621681495896"><span class="hs-identifier hs-var">q</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Simplification -&gt; IntMap (Arg Term) -&gt; Match Term
forall a. Simplification -&gt; IntMap (Arg a) -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#Yes"><span class="hs-identifier hs-var">Yes</span></a></span><span> </span><span class="annot"><span class="annottext">Simplification
</span><a href="Agda.TypeChecking.Monad.Base.html#YesSimplification"><span class="hs-identifier hs-var">YesSimplification</span></a></span><span> </span><span class="annot"><span class="annottext">IntMap (Arg Term)
forall a. Null a =&gt; a
</span><a href="Agda.Utils.Null.html#empty"><span class="hs-identifier hs-var">empty</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Elim
</span><a href="#local-6989586621681495891"><span class="hs-identifier hs-var">elim</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-177"></span><span>                     </span><span class="hs-keyword">else</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Match Term
forall a. Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span><span class="hs-special">,</span><span>                          </span><span class="annot"><span class="annottext">Elim
</span><a href="#local-6989586621681495891"><span class="hs-identifier hs-var">elim</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-178"></span><span class="hs-comment">-- The following two cases are not impossible, see #2964</span><span>
</span><span id="line-179"></span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#matchCopattern"><span class="hs-identifier hs-var">matchCopattern</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#ProjP"><span class="hs-identifier hs-type">ProjP</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span id="local-6989586621681495899"><span class="annot"><span class="annottext">elim :: Elim
</span><a href="#local-6989586621681495899"><span class="hs-identifier hs-var">elim</span></a></span></span><span class="hs-glyph">@</span><span class="annot"><a href="Agda.Syntax.Internal.Elim.html#Apply"><span class="hs-identifier hs-type">Apply</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Match Term, Elim) -&gt; m (Match Term, Elim)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Match Term
forall a. Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span><span> </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Elim
</span><a href="#local-6989586621681495899"><span class="hs-identifier hs-var">elim</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-180"></span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#matchCopattern"><span class="hs-identifier hs-var">matchCopattern</span></a></span><span> </span><span class="annot"><span class="annottext">DeBruijnPattern
</span><span class="hs-identifier">_</span></span><span>       </span><span id="local-6989586621681495900"><span class="annot"><span class="annottext">elim :: Elim
</span><a href="#local-6989586621681495900"><span class="hs-identifier hs-var">elim</span></a></span></span><span class="hs-glyph">@</span><span class="annot"><a href="Agda.Syntax.Internal.Elim.html#Proj"><span class="hs-identifier hs-type">Proj</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Match Term, Elim) -&gt; m (Match Term, Elim)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Match Term
forall a. Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span><span> </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Elim
</span><a href="#local-6989586621681495900"><span class="hs-identifier hs-var">elim</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-181"></span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#matchCopattern"><span class="hs-identifier hs-var">matchCopattern</span></a></span><span> </span><span id="local-6989586621681495901"><span class="annot"><span class="annottext">DeBruijnPattern
</span><a href="#local-6989586621681495901"><span class="hs-identifier hs-var">p</span></a></span></span><span>       </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.Elim.html#Apply"><span class="hs-identifier hs-type">Apply</span></a></span><span> </span><span id="local-6989586621681495902"><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621681495902"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Arg Term -&gt; Elim) -&gt; (Match Term, Arg Term) -&gt; (Match Term, Elim)
forall b d a. (b -&gt; d) -&gt; (a, b) -&gt; (a, d)
</span><a href="Agda.Utils.Tuple.html#mapSnd"><span class="hs-identifier hs-var">mapSnd</span></a></span><span> </span><span class="annot"><span class="annottext">Arg Term -&gt; Elim
forall a. Arg a -&gt; Elim' a
</span><a href="Agda.Syntax.Internal.Elim.html#Apply"><span class="hs-identifier hs-var">Apply</span></a></span><span> </span><span class="annot"><span class="annottext">((Match Term, Arg Term) -&gt; (Match Term, Elim))
-&gt; m (Match Term, Arg Term) -&gt; m (Match Term, Elim)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">DeBruijnPattern -&gt; Arg Term -&gt; m (Match Term, Arg Term)
forall (m :: * -&gt; *).
MonadMatch m =&gt;
DeBruijnPattern -&gt; Arg Term -&gt; m (Match Term, Arg Term)
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchPattern"><span class="hs-identifier hs-var">matchPattern</span></a></span><span> </span><span class="annot"><span class="annottext">DeBruijnPattern
</span><a href="#local-6989586621681495901"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621681495902"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-182"></span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#matchCopattern"><span class="hs-identifier hs-var">matchCopattern</span></a></span><span> </span><span id="local-6989586621681495906"><span class="annot"><span class="annottext">DeBruijnPattern
</span><a href="#local-6989586621681495906"><span class="hs-identifier hs-var">p</span></a></span></span><span>       </span><span id="local-6989586621681495907"><span class="annot"><span class="annottext">e :: Elim
</span><a href="#local-6989586621681495907"><span class="hs-identifier hs-var">e</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.Elim.html#IApply"><span class="hs-identifier hs-type">IApply</span></a></span><span> </span><span id="local-6989586621681495908"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621681495908"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621681495909"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621681495909"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span id="local-6989586621681495910"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621681495910"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Arg Term -&gt; Elim) -&gt; (Match Term, Arg Term) -&gt; (Match Term, Elim)
forall b d a. (b -&gt; d) -&gt; (a, b) -&gt; (a, d)
</span><a href="Agda.Utils.Tuple.html#mapSnd"><span class="hs-identifier hs-var">mapSnd</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Elim -&gt; Arg Term -&gt; Elim
</span><a href="Agda.TypeChecking.Patterns.Match.html#mergeElim"><span class="hs-identifier hs-var">mergeElim</span></a></span><span> </span><span class="annot"><span class="annottext">Elim
</span><a href="#local-6989586621681495907"><span class="hs-identifier hs-var">e</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">((Match Term, Arg Term) -&gt; (Match Term, Elim))
-&gt; m (Match Term, Arg Term) -&gt; m (Match Term, Elim)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">DeBruijnPattern -&gt; Arg Term -&gt; m (Match Term, Arg Term)
forall (m :: * -&gt; *).
MonadMatch m =&gt;
DeBruijnPattern -&gt; Arg Term -&gt; m (Match Term, Arg Term)
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchPattern"><span class="hs-identifier hs-var">matchPattern</span></a></span><span> </span><span class="annot"><span class="annottext">DeBruijnPattern
</span><a href="#local-6989586621681495906"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Term -&gt; Arg Term
forall a. a -&gt; Arg a
</span><a href="Agda.Syntax.Common.html#defaultArg"><span class="hs-identifier hs-var">defaultArg</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621681495910"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-183"></span><span>
</span><span id="line-184"></span><span class="hs-pragma">{-# SPECIALIZE</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#matchPatterns"><span class="hs-pragma hs-type">matchPatterns</span></a></span><span> </span><span class="hs-pragma">::</span><span> </span><span class="hs-pragma">[</span><span class="annot"><a href="Agda.Syntax.Common.html#NamedArg"><span class="hs-pragma hs-type">NamedArg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#DeBruijnPattern"><span class="hs-pragma hs-type">DeBruijnPattern</span></a></span><span class="hs-pragma">]</span><span> </span><span class="hs-pragma">-&gt;</span><span> </span><span class="hs-pragma">[</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-pragma hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-pragma hs-type">Term</span></a></span><span class="hs-pragma">]</span><span> </span><span class="hs-pragma">-&gt;</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Monad.Base.html#TCM"><span class="hs-pragma hs-type">TCM</span></a></span><span> </span><span class="hs-pragma">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-pragma hs-type">Match</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-pragma hs-type">Term</span></a></span><span class="hs-pragma">,</span><span> </span><span class="hs-pragma">[</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-pragma hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-pragma hs-type">Term</span></a></span><span class="hs-pragma">]</span><span class="hs-pragma">)</span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-185"></span><span id="local-6989586621681495509"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#matchPatterns"><span class="hs-identifier hs-type">matchPatterns</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#MonadMatch"><span class="hs-identifier hs-type">MonadMatch</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681495509"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-186"></span><span>              </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Common.html#NamedArg"><span class="hs-identifier hs-type">NamedArg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#DeBruijnPattern"><span class="hs-identifier hs-type">DeBruijnPattern</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-187"></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-188"></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681495509"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span></span><span>
</span><span id="line-189"></span><span id="matchPatterns"><span class="annot"><span class="annottext">matchPatterns :: forall (m :: * -&gt; *).
MonadMatch m =&gt;
[NamedArg DeBruijnPattern]
-&gt; [Arg Term] -&gt; m (Match Term, [Arg Term])
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchPatterns"><span class="hs-identifier hs-var hs-var">matchPatterns</span></a></span></span><span> </span><span id="local-6989586621681495995"><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621681495995"><span class="hs-identifier hs-var">ps</span></a></span></span><span> </span><span id="local-6989586621681495996"><span class="annot"><span class="annottext">[Arg Term]
</span><a href="#local-6989586621681495996"><span class="hs-identifier hs-var">vs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-190"></span><span>  </span><span class="annot"><span class="annottext">VerboseKey -&gt; Int -&gt; TCMT IO Doc -&gt; m ()
forall (m :: * -&gt; *).
MonadDebug m =&gt;
VerboseKey -&gt; Int -&gt; TCMT IO Doc -&gt; m ()
</span><a href="Agda.TypeChecking.Monad.Debug.html#reportSDoc"><span class="hs-identifier hs-var">reportSDoc</span></a></span><span> </span><span class="annot"><span class="annottext">VerboseKey
</span><span class="hs-string">&quot;tc.match&quot;</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">20</span></span><span> </span><span class="annot"><span class="annottext">(TCMT IO Doc -&gt; m ()) -&gt; TCMT IO Doc -&gt; m ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-191"></span><span>     </span><span class="annot"><span class="annottext">[TCMT IO Doc] -&gt; TCMT IO Doc
forall (m :: * -&gt; *) (t :: * -&gt; *).
(Applicative m, Foldable t) =&gt;
t (m Doc) -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#vcat"><span class="hs-identifier hs-var">vcat</span></a></span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc
</span><span class="hs-string">&quot;matchPatterns&quot;</span></span><span>
</span><span id="line-192"></span><span>          </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Int -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall (m :: * -&gt; *). Functor m =&gt; Int -&gt; m Doc -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#nest"><span class="hs-identifier hs-var">nest</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span> </span><span class="annot"><span class="annottext">(TCMT IO Doc -&gt; TCMT IO Doc) -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc
</span><span class="hs-string">&quot;ps =&quot;</span></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall (m :: * -&gt; *). Applicative m =&gt; m Doc -&gt; m Doc -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern] -&gt; TCMT IO Doc
forall (m :: * -&gt; *).
MonadPretty m =&gt;
[NamedArg DeBruijnPattern] -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#prettyTCMPatternList"><span class="hs-identifier hs-var">prettyTCMPatternList</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621681495995"><span class="hs-identifier hs-var">ps</span></a></span><span>
</span><span id="line-193"></span><span>          </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Int -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall (m :: * -&gt; *). Functor m =&gt; Int -&gt; m Doc -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#nest"><span class="hs-identifier hs-var">nest</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span> </span><span class="annot"><span class="annottext">(TCMT IO Doc -&gt; TCMT IO Doc) -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc
</span><span class="hs-string">&quot;vs =&quot;</span></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall (m :: * -&gt; *). Applicative m =&gt; m Doc -&gt; m Doc -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">[TCMT IO Doc] -&gt; TCMT IO Doc
forall (m :: * -&gt; *) (t :: * -&gt; *).
(Applicative m, Foldable t) =&gt;
t (m Doc) -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#fsep"><span class="hs-identifier hs-var">fsep</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TCMT IO Doc -&gt; [TCMT IO Doc] -&gt; [TCMT IO Doc]
forall (m :: * -&gt; *) (t :: * -&gt; *).
(Applicative m, Semigroup (m Doc), Foldable t) =&gt;
m Doc -&gt; t (m Doc) -&gt; [m Doc]
</span><a href="Agda.TypeChecking.Pretty.html#punctuate"><span class="hs-identifier hs-var">punctuate</span></a></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc
forall (m :: * -&gt; *). Applicative m =&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#comma"><span class="hs-identifier hs-var">comma</span></a></span><span> </span><span class="annot"><span class="annottext">([TCMT IO Doc] -&gt; [TCMT IO Doc]) -&gt; [TCMT IO Doc] -&gt; [TCMT IO Doc]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Arg Term -&gt; TCMT IO Doc) -&gt; [Arg Term] -&gt; [TCMT IO Doc]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Arg Term -&gt; TCMT IO Doc
forall a (m :: * -&gt; *). (PrettyTCM a, MonadPretty m) =&gt; a -&gt; m Doc
forall (m :: * -&gt; *). MonadPretty m =&gt; Arg Term -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#prettyTCM"><span class="hs-identifier hs-var">prettyTCM</span></a></span><span> </span><span class="annot"><span class="annottext">[Arg Term]
</span><a href="#local-6989586621681495996"><span class="hs-identifier hs-var">vs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-194"></span><span>          </span><span class="hs-special">]</span><span>
</span><span id="line-195"></span><span>
</span><span id="line-196"></span><span>  </span><span class="annot"><span class="annottext">VerboseKey
-&gt; Int
-&gt; TCMT IO Doc
-&gt; m (Match Term, [Arg Term])
-&gt; m (Match Term, [Arg Term])
forall (m :: * -&gt; *) a.
MonadDebug m =&gt;
VerboseKey -&gt; Int -&gt; TCMT IO Doc -&gt; m a -&gt; m a
</span><a href="Agda.TypeChecking.Monad.Debug.html#traceSDoc"><span class="hs-identifier hs-var">traceSDoc</span></a></span><span> </span><span class="annot"><span class="annottext">VerboseKey
</span><span class="hs-string">&quot;tc.match&quot;</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">50</span></span><span>
</span><span id="line-197"></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TCMT IO Doc] -&gt; TCMT IO Doc
forall (m :: * -&gt; *) (t :: * -&gt; *).
(Applicative m, Foldable t) =&gt;
t (m Doc) -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#vcat"><span class="hs-identifier hs-var">vcat</span></a></span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc
</span><span class="hs-string">&quot;matchPatterns&quot;</span></span><span>
</span><span id="line-198"></span><span>          </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Int -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall (m :: * -&gt; *). Functor m =&gt; Int -&gt; m Doc -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#nest"><span class="hs-identifier hs-var">nest</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span> </span><span class="annot"><span class="annottext">(TCMT IO Doc -&gt; TCMT IO Doc) -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc
</span><span class="hs-string">&quot;ps =&quot;</span></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall (m :: * -&gt; *). Applicative m =&gt; m Doc -&gt; m Doc -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">[TCMT IO Doc] -&gt; TCMT IO Doc
forall (m :: * -&gt; *) (t :: * -&gt; *).
(Applicative m, Foldable t) =&gt;
t (m Doc) -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#fsep"><span class="hs-identifier hs-var">fsep</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TCMT IO Doc -&gt; [TCMT IO Doc] -&gt; [TCMT IO Doc]
forall (m :: * -&gt; *) (t :: * -&gt; *).
(Applicative m, Semigroup (m Doc), Foldable t) =&gt;
m Doc -&gt; t (m Doc) -&gt; [m Doc]
</span><a href="Agda.TypeChecking.Pretty.html#punctuate"><span class="hs-identifier hs-var">punctuate</span></a></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc
forall (m :: * -&gt; *). Applicative m =&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#comma"><span class="hs-identifier hs-var">comma</span></a></span><span> </span><span class="annot"><span class="annottext">([TCMT IO Doc] -&gt; [TCMT IO Doc]) -&gt; [TCMT IO Doc] -&gt; [TCMT IO Doc]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(NamedArg DeBruijnPattern -&gt; TCMT IO Doc)
-&gt; [NamedArg DeBruijnPattern] -&gt; [TCMT IO Doc]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">VerboseKey -&gt; TCMT IO Doc
forall (m :: * -&gt; *). Applicative m =&gt; VerboseKey -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">(VerboseKey -&gt; TCMT IO Doc)
-&gt; (NamedArg DeBruijnPattern -&gt; VerboseKey)
-&gt; NamedArg DeBruijnPattern
-&gt; TCMT IO Doc
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">NamedArg DeBruijnPattern -&gt; VerboseKey
forall a. Show a =&gt; a -&gt; VerboseKey
</span><span class="hs-identifier hs-var">show</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621681495995"><span class="hs-identifier hs-var">ps</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-199"></span><span>          </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Int -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall (m :: * -&gt; *). Functor m =&gt; Int -&gt; m Doc -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#nest"><span class="hs-identifier hs-var">nest</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span> </span><span class="annot"><span class="annottext">(TCMT IO Doc -&gt; TCMT IO Doc) -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc
</span><span class="hs-string">&quot;vs =&quot;</span></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall (m :: * -&gt; *). Applicative m =&gt; m Doc -&gt; m Doc -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">[TCMT IO Doc] -&gt; TCMT IO Doc
forall (m :: * -&gt; *) (t :: * -&gt; *).
(Applicative m, Foldable t) =&gt;
t (m Doc) -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#fsep"><span class="hs-identifier hs-var">fsep</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TCMT IO Doc -&gt; [TCMT IO Doc] -&gt; [TCMT IO Doc]
forall (m :: * -&gt; *) (t :: * -&gt; *).
(Applicative m, Semigroup (m Doc), Foldable t) =&gt;
m Doc -&gt; t (m Doc) -&gt; [m Doc]
</span><a href="Agda.TypeChecking.Pretty.html#punctuate"><span class="hs-identifier hs-var">punctuate</span></a></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc
forall (m :: * -&gt; *). Applicative m =&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#comma"><span class="hs-identifier hs-var">comma</span></a></span><span> </span><span class="annot"><span class="annottext">([TCMT IO Doc] -&gt; [TCMT IO Doc]) -&gt; [TCMT IO Doc] -&gt; [TCMT IO Doc]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Arg Term -&gt; TCMT IO Doc) -&gt; [Arg Term] -&gt; [TCMT IO Doc]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Arg Term -&gt; TCMT IO Doc
forall a (m :: * -&gt; *). (PrettyTCM a, MonadPretty m) =&gt; a -&gt; m Doc
forall (m :: * -&gt; *). MonadPretty m =&gt; Arg Term -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#prettyTCM"><span class="hs-identifier hs-var">prettyTCM</span></a></span><span> </span><span class="annot"><span class="annottext">[Arg Term]
</span><a href="#local-6989586621681495996"><span class="hs-identifier hs-var">vs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-200"></span><span>          </span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(m (Match Term, [Arg Term]) -&gt; m (Match Term, [Arg Term]))
-&gt; m (Match Term, [Arg Term]) -&gt; m (Match Term, [Arg Term])
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-201"></span><span>  </span><span class="hs-comment">-- Buggy, see issue 1124:</span><span>
</span><span id="line-202"></span><span>  </span><span class="hs-comment">-- (ms,vs) &lt;- unzip &lt;$&gt; zipWithM' (matchPattern . namedArg) ps vs</span><span>
</span><span id="line-203"></span><span>  </span><span class="hs-comment">-- return (mconcat ms, vs)</span><span>
</span><span id="line-204"></span><span>  </span><span class="annot"><span class="annottext">(NamedArg DeBruijnPattern -&gt; Arg Term -&gt; m (Match Term, Arg Term))
-&gt; [NamedArg DeBruijnPattern]
-&gt; [Arg Term]
-&gt; m (Match Term, [Arg Term])
forall (m :: * -&gt; *) p v.
(IsProjP p, MonadMatch m) =&gt;
(p -&gt; v -&gt; m (Match Term, v)) -&gt; [p] -&gt; [v] -&gt; m (Match Term, [v])
</span><a href="Agda.TypeChecking.Patterns.Match.html#foldMatch"><span class="hs-identifier hs-var">foldMatch</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DeBruijnPattern -&gt; Arg Term -&gt; m (Match Term, Arg Term)
forall (m :: * -&gt; *).
MonadMatch m =&gt;
DeBruijnPattern -&gt; Arg Term -&gt; m (Match Term, Arg Term)
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchPattern"><span class="hs-identifier hs-var">matchPattern</span></a></span><span> </span><span class="annot"><span class="annottext">(DeBruijnPattern -&gt; Arg Term -&gt; m (Match Term, Arg Term))
-&gt; (NamedArg DeBruijnPattern -&gt; DeBruijnPattern)
-&gt; NamedArg DeBruijnPattern
-&gt; Arg Term
-&gt; m (Match Term, Arg Term)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">NamedArg DeBruijnPattern -&gt; DeBruijnPattern
forall a. NamedArg a -&gt; a
</span><a href="Agda.Syntax.Common.html#namedArg"><span class="hs-identifier hs-var">namedArg</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621681495995"><span class="hs-identifier hs-var">ps</span></a></span><span> </span><span class="annot"><span class="annottext">[Arg Term]
</span><a href="#local-6989586621681495996"><span class="hs-identifier hs-var">vs</span></a></span><span>
</span><span id="line-205"></span><span>
</span><span id="line-206"></span><span class="annot"><span class="hs-comment">-- | Match a single pattern.</span></span><span>
</span><span id="line-207"></span><span id="local-6989586621681495507"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#matchPattern"><span class="hs-identifier hs-type">matchPattern</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#MonadMatch"><span class="hs-identifier hs-type">MonadMatch</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681495507"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-208"></span><span>             </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#DeBruijnPattern"><span class="hs-identifier hs-type">DeBruijnPattern</span></a></span><span>
</span><span id="line-209"></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span>
</span><span id="line-210"></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681495507"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-211"></span><span id="matchPattern"><span class="annot"><span class="annottext">matchPattern :: forall (m :: * -&gt; *).
MonadMatch m =&gt;
DeBruijnPattern -&gt; Arg Term -&gt; m (Match Term, Arg Term)
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchPattern"><span class="hs-identifier hs-var hs-var">matchPattern</span></a></span></span><span> </span><span id="local-6989586621681496053"><span class="annot"><span class="annottext">DeBruijnPattern
</span><a href="#local-6989586621681496053"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621681496054"><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621681496054"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DeBruijnPattern
</span><a href="#local-6989586621681496053"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621681496054"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-212"></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#ProjP"><span class="hs-identifier hs-type">ProjP</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><span class="hs-identifier">_</span></span><span>            </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match Term, Arg Term)
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span>
</span><span id="line-213"></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#IApplyP"><span class="hs-identifier hs-type">IApplyP</span></a></span><span> </span><span class="annot"><span class="annottext">PatternInfo
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681496056"><span class="annot"><span class="annottext">DBPatVar
</span><a href="#local-6989586621681496056"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-special">,</span><span> </span><span id="local-6989586621681496057"><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621681496057"><span class="hs-identifier hs-var">arg</span></a></span></span><span> </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Match Term, Arg Term) -&gt; m (Match Term, Arg Term)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Simplification -&gt; IntMap (Arg Term) -&gt; Match Term
forall a. Simplification -&gt; IntMap (Arg a) -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#Yes"><span class="hs-identifier hs-var">Yes</span></a></span><span> </span><span class="annot"><span class="annottext">Simplification
</span><a href="Agda.TypeChecking.Monad.Base.html#NoSimplification"><span class="hs-identifier hs-var">NoSimplification</span></a></span><span> </span><span class="annot"><span class="annottext">IntMap (Arg Term)
</span><a href="#local-6989586621681496059"><span class="hs-identifier hs-var">entry</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621681496057"><span class="hs-identifier hs-var">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-214"></span><span>    </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621681496059"><span class="annot"><span class="annottext">entry :: IntMap (Arg Term)
</span><a href="#local-6989586621681496059"><span class="hs-identifier hs-var hs-var">entry</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Int, Arg Term) -&gt; IntMap (Arg Term)
forall el coll. Singleton el coll =&gt; el -&gt; coll
</span><a href="Agda.Utils.Singleton.html#singleton"><span class="hs-identifier hs-var">singleton</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DBPatVar -&gt; Int
</span><a href="Agda.Syntax.Internal.html#dbPatVarIndex"><span class="hs-identifier hs-var">dbPatVarIndex</span></a></span><span> </span><span class="annot"><span class="annottext">DBPatVar
</span><a href="#local-6989586621681496056"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621681496057"><span class="hs-identifier hs-var">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-215"></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#VarP"><span class="hs-identifier hs-type">VarP</span></a></span><span> </span><span class="annot"><span class="annottext">PatternInfo
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681496063"><span class="annot"><span class="annottext">DBPatVar
</span><a href="#local-6989586621681496063"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-special">,</span><span> </span><span id="local-6989586621681496064"><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621681496064"><span class="hs-identifier hs-var">arg</span></a></span></span><span>          </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Match Term, Arg Term) -&gt; m (Match Term, Arg Term)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Simplification -&gt; IntMap (Arg Term) -&gt; Match Term
forall a. Simplification -&gt; IntMap (Arg a) -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#Yes"><span class="hs-identifier hs-var">Yes</span></a></span><span> </span><span class="annot"><span class="annottext">Simplification
</span><a href="Agda.TypeChecking.Monad.Base.html#NoSimplification"><span class="hs-identifier hs-var">NoSimplification</span></a></span><span> </span><span class="annot"><span class="annottext">IntMap (Arg Term)
</span><a href="#local-6989586621681496065"><span class="hs-identifier hs-var">entry</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621681496064"><span class="hs-identifier hs-var">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-216"></span><span>    </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621681496065"><span class="annot"><span class="annottext">entry :: IntMap (Arg Term)
</span><a href="#local-6989586621681496065"><span class="hs-identifier hs-var hs-var">entry</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Int, Arg Term) -&gt; IntMap (Arg Term)
forall el coll. Singleton el coll =&gt; el -&gt; coll
</span><a href="Agda.Utils.Singleton.html#singleton"><span class="hs-identifier hs-var">singleton</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DBPatVar -&gt; Int
</span><a href="Agda.Syntax.Internal.html#dbPatVarIndex"><span class="hs-identifier hs-var">dbPatVarIndex</span></a></span><span> </span><span class="annot"><span class="annottext">DBPatVar
</span><a href="#local-6989586621681496063"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621681496064"><span class="hs-identifier hs-var">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-217"></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#DotP"><span class="hs-identifier hs-type">DotP</span></a></span><span> </span><span class="annot"><span class="annottext">PatternInfo
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-special">,</span><span> </span><span id="local-6989586621681496067"><span class="annot"><span class="annottext">arg :: Arg Term
</span><a href="#local-6989586621681496067"><span class="hs-identifier hs-var">arg</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><span class="annottext">ArgInfo
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681496069"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621681496069"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Match Term, Arg Term) -&gt; m (Match Term, Arg Term)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Simplification -&gt; IntMap (Arg Term) -&gt; Match Term
forall a. Simplification -&gt; IntMap (Arg a) -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#Yes"><span class="hs-identifier hs-var">Yes</span></a></span><span> </span><span class="annot"><span class="annottext">Simplification
</span><a href="Agda.TypeChecking.Monad.Base.html#NoSimplification"><span class="hs-identifier hs-var">NoSimplification</span></a></span><span> </span><span class="annot"><span class="annottext">IntMap (Arg Term)
forall a. Null a =&gt; a
</span><a href="Agda.Utils.Null.html#empty"><span class="hs-identifier hs-var">empty</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621681496067"><span class="hs-identifier hs-var">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-218"></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#LitP"><span class="hs-identifier hs-type">LitP</span></a></span><span> </span><span class="annot"><span class="annottext">PatternInfo
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681496071"><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621681496071"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-special">,</span><span> </span><span id="local-6989586621681496072"><span class="annot"><span class="annottext">arg :: Arg Term
</span><a href="#local-6989586621681496072"><span class="hs-identifier hs-var">arg</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><span class="annottext">ArgInfo
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681496073"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621681496073"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-219"></span><span>    </span><span id="local-6989586621681496074"><span class="annot"><span class="annottext">Blocked Term
</span><a href="#local-6989586621681496074"><span class="hs-identifier hs-var">w</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Term -&gt; m (Blocked Term)
forall a (m :: * -&gt; *).
(Reduce a, MonadReduce m) =&gt;
a -&gt; m (Blocked a)
</span><a href="Agda.TypeChecking.Reduce.html#reduceB"><span class="hs-identifier hs-var">reduceB</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621681496073"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-220"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621681496076"><span class="annot"><span class="annottext">arg' :: Arg Term
</span><a href="#local-6989586621681496076"><span class="hs-identifier hs-var hs-var">arg'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621681496072"><span class="hs-identifier hs-var">arg</span></a></span><span> </span><span class="annot"><span class="annottext">Arg Term -&gt; Term -&gt; Arg Term
forall (f :: * -&gt; *) a b. Functor f =&gt; f a -&gt; b -&gt; f b
</span><span class="hs-operator hs-var">$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Blocked Term -&gt; Term
forall t a. Blocked' t a -&gt; a
</span><a href="Agda.Syntax.Internal.Blockers.html#ignoreBlocking"><span class="hs-identifier hs-var">ignoreBlocking</span></a></span><span> </span><span class="annot"><span class="annottext">Blocked Term
</span><a href="#local-6989586621681496074"><span class="hs-identifier hs-var">w</span></a></span><span>
</span><span id="line-221"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Blocked Term
</span><a href="#local-6989586621681496074"><span class="hs-identifier hs-var">w</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-222"></span><span>      </span><span class="annot"><a href="Agda.Syntax.Internal.Blockers.html#NotBlocked"><span class="hs-identifier hs-type">NotBlocked</span></a></span><span> </span><span class="annot"><span class="annottext">NotBlocked' Term
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#Lit"><span class="hs-identifier hs-type">Lit</span></a></span><span> </span><span id="local-6989586621681496080"><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621681496080"><span class="hs-identifier hs-var">l'</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-223"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621681496071"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">Literal -&gt; Literal -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621681496080"><span class="hs-identifier hs-var">l'</span></a></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Match Term, Arg Term) -&gt; m (Match Term, Arg Term)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Simplification -&gt; IntMap (Arg Term) -&gt; Match Term
forall a. Simplification -&gt; IntMap (Arg a) -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#Yes"><span class="hs-identifier hs-var">Yes</span></a></span><span> </span><span class="annot"><span class="annottext">Simplification
</span><a href="Agda.TypeChecking.Monad.Base.html#YesSimplification"><span class="hs-identifier hs-var">YesSimplification</span></a></span><span> </span><span class="annot"><span class="annottext">IntMap (Arg Term)
forall a. Null a =&gt; a
</span><a href="Agda.Utils.Null.html#empty"><span class="hs-identifier hs-var">empty</span></a></span><span> </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621681496076"><span class="hs-identifier hs-var">arg'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-224"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Match Term, Arg Term) -&gt; m (Match Term, Arg Term)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Match Term
forall a. Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span><span>                          </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621681496076"><span class="hs-identifier hs-var">arg'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-225"></span><span>      </span><span class="annot"><a href="Agda.Syntax.Internal.Blockers.html#Blocked"><span class="hs-identifier hs-type">Blocked</span></a></span><span> </span><span id="local-6989586621681496082"><span class="annot"><span class="annottext">Blocker
</span><a href="#local-6989586621681496082"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Match Term, Arg Term) -&gt; m (Match Term, Arg Term)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Blocked () -&gt; Match Term
forall a. Blocked () -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#DontKnow"><span class="hs-identifier hs-var">DontKnow</span></a></span><span> </span><span class="annot"><span class="annottext">(Blocked () -&gt; Match Term) -&gt; Blocked () -&gt; Match Term
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Blocker -&gt; () -&gt; Blocked ()
forall t a. Blocker -&gt; a -&gt; Blocked' t a
</span><a href="Agda.Syntax.Internal.Blockers.html#Blocked"><span class="hs-identifier hs-var">Blocked</span></a></span><span> </span><span class="annot"><span class="annottext">Blocker
</span><a href="#local-6989586621681496082"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>     </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621681496076"><span class="hs-identifier hs-var">arg'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-226"></span><span>      </span><span class="annot"><a href="Agda.Syntax.Internal.Blockers.html#NotBlocked"><span class="hs-identifier hs-type">NotBlocked</span></a></span><span> </span><span id="local-6989586621681496083"><span class="annot"><span class="annottext">NotBlocked' Term
</span><a href="#local-6989586621681496083"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span id="local-6989586621681496084"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621681496084"><span class="hs-identifier hs-var">t</span></a></span></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Match Term, Arg Term) -&gt; m (Match Term, Arg Term)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Blocked () -&gt; Match Term
forall a. Blocked () -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#DontKnow"><span class="hs-identifier hs-var">DontKnow</span></a></span><span> </span><span class="annot"><span class="annottext">(Blocked () -&gt; Match Term) -&gt; Blocked () -&gt; Match Term
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">NotBlocked' Term -&gt; () -&gt; Blocked ()
forall t a. NotBlocked' t -&gt; a -&gt; Blocked' t a
</span><a href="Agda.Syntax.Internal.Blockers.html#NotBlocked"><span class="hs-identifier hs-var">NotBlocked</span></a></span><span> </span><span class="annot"><span class="annottext">NotBlocked' Term
</span><a href="#local-6989586621681496085"><span class="hs-identifier hs-var">r'</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621681496076"><span class="hs-identifier hs-var">arg'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-227"></span><span>        </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621681496085"><span class="annot"><span class="annottext">r' :: NotBlocked' Term
</span><a href="#local-6989586621681496085"><span class="hs-identifier hs-var hs-var">r'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Elim -&gt; NotBlocked' Term -&gt; NotBlocked' Term
forall t. Elim' t -&gt; NotBlocked' t -&gt; NotBlocked' t
</span><a href="Agda.Syntax.Internal.Blockers.html#stuckOn"><span class="hs-identifier hs-var">stuckOn</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Arg Term -&gt; Elim
forall a. Arg a -&gt; Elim' a
</span><a href="Agda.Syntax.Internal.Elim.html#Apply"><span class="hs-identifier hs-var">Apply</span></a></span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621681496076"><span class="hs-identifier hs-var">arg'</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">NotBlocked' Term
</span><a href="#local-6989586621681496083"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-228"></span><span>
</span><span id="line-229"></span><span>  </span><span class="hs-comment">-- Case constructor pattern.</span><span>
</span><span id="line-230"></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#ConP"><span class="hs-identifier hs-type">ConP</span></a></span><span> </span><span id="local-6989586621681496088"><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621681496088"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621681496089"><span class="annot"><span class="annottext">ConPatternInfo
</span><a href="#local-6989586621681496089"><span class="hs-identifier hs-var">cpi</span></a></span></span><span> </span><span id="local-6989586621681496090"><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621681496090"><span class="hs-identifier hs-var">ps</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span id="local-6989586621681496091"><span class="annot"><span class="annottext">ArgInfo
</span><a href="#local-6989586621681496091"><span class="hs-identifier hs-var">info</span></a></span></span><span> </span><span id="local-6989586621681496092"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621681496092"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-231"></span><span>    </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ConPatternInfo -&gt; Bool
</span><a href="Agda.Syntax.Internal.html#conPRecord"><span class="hs-identifier hs-var">conPRecord</span></a></span><span> </span><span class="annot"><span class="annottext">ConPatternInfo
</span><a href="#local-6989586621681496089"><span class="hs-identifier hs-var">cpi</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">ConHead
-&gt; [NamedArg DeBruijnPattern]
-&gt; Arg Term
-&gt; m (Match Term, Arg Term)
forall (m :: * -&gt; *).
MonadMatch m =&gt;
ConHead
-&gt; [NamedArg DeBruijnPattern]
-&gt; Arg Term
-&gt; m (Match Term, Arg Term)
</span><a href="#local-6989586621681496095"><span class="hs-identifier hs-var">fallback</span></a></span><span> </span><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621681496088"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621681496090"><span class="hs-identifier hs-var">ps</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ArgInfo -&gt; Term -&gt; Arg Term
forall e. ArgInfo -&gt; e -&gt; Arg e
</span><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-var">Arg</span></a></span><span> </span><span class="annot"><span class="annottext">ArgInfo
</span><a href="#local-6989586621681496091"><span class="hs-identifier hs-var">info</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621681496092"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">else</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-232"></span><span>    </span><span class="annot"><span class="annottext">QName -&gt; m (Maybe [Arg QName])
forall (m :: * -&gt; *).
HasConstInfo m =&gt;
QName -&gt; m (Maybe [Arg QName])
</span><a href="#local-6989586621681496096"><span class="hs-identifier hs-var">isEtaRecordCon</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ConHead -&gt; QName
</span><a href="Agda.Syntax.Internal.html#conName"><span class="hs-identifier hs-var">conName</span></a></span><span> </span><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621681496088"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">m (Maybe [Arg QName])
-&gt; (Maybe [Arg QName] -&gt; m (Match Term, Arg Term))
-&gt; m (Match Term, Arg Term)
forall a b. m a -&gt; (a -&gt; m b) -&gt; m b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-233"></span><span>      </span><span class="annot"><span class="annottext">Maybe [Arg QName]
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ConHead
-&gt; [NamedArg DeBruijnPattern]
-&gt; Arg Term
-&gt; m (Match Term, Arg Term)
forall (m :: * -&gt; *).
MonadMatch m =&gt;
ConHead
-&gt; [NamedArg DeBruijnPattern]
-&gt; Arg Term
-&gt; m (Match Term, Arg Term)
</span><a href="#local-6989586621681496095"><span class="hs-identifier hs-var">fallback</span></a></span><span> </span><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621681496088"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621681496090"><span class="hs-identifier hs-var">ps</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ArgInfo -&gt; Term -&gt; Arg Term
forall e. ArgInfo -&gt; e -&gt; Arg e
</span><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-var">Arg</span></a></span><span> </span><span class="annot"><span class="annottext">ArgInfo
</span><a href="#local-6989586621681496091"><span class="hs-identifier hs-var">info</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621681496092"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-234"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621681496098"><span class="annot"><span class="annottext">[Arg QName]
</span><a href="#local-6989586621681496098"><span class="hs-identifier hs-var">fs</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-235"></span><span>        </span><span class="hs-comment">-- Case: Eta record constructor.</span><span>
</span><span id="line-236"></span><span>        </span><span class="hs-comment">-- This case is necessary if we want to use the clauses before</span><span>
</span><span id="line-237"></span><span>        </span><span class="hs-comment">-- record pattern translation (e.g., in type-checking definitions by copatterns).</span><span>
</span><span id="line-238"></span><span>        </span><span class="annot"><span class="annottext">Bool -&gt; m () -&gt; m ()
forall (f :: * -&gt; *). Applicative f =&gt; Bool -&gt; f () -&gt; f ()
</span><span class="hs-identifier hs-var">unless</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Arg QName] -&gt; Int
forall a. Sized a =&gt; a -&gt; Int
</span><a href="Agda.Utils.Size.html#size"><span class="hs-identifier hs-var">size</span></a></span><span> </span><span class="annot"><span class="annottext">[Arg QName]
</span><a href="#local-6989586621681496098"><span class="hs-identifier hs-var">fs</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern] -&gt; Int
forall a. Sized a =&gt; a -&gt; Int
</span><a href="Agda.Utils.Size.html#size"><span class="hs-identifier hs-var">size</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621681496090"><span class="hs-identifier hs-var">ps</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">m ()
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span>
</span><span id="line-239"></span><span>        </span><span class="annot"><span class="annottext">([Arg Term] -&gt; Arg Term)
-&gt; (Match Term, [Arg Term]) -&gt; (Match Term, Arg Term)
forall b d a. (b -&gt; d) -&gt; (a, b) -&gt; (a, d)
</span><a href="Agda.Utils.Tuple.html#mapSnd"><span class="hs-identifier hs-var">mapSnd</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ArgInfo -&gt; Term -&gt; Arg Term
forall e. ArgInfo -&gt; e -&gt; Arg e
</span><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-var">Arg</span></a></span><span> </span><span class="annot"><span class="annottext">ArgInfo
</span><a href="#local-6989586621681496091"><span class="hs-identifier hs-var">info</span></a></span><span> </span><span class="annot"><span class="annottext">(Term -&gt; Arg Term)
-&gt; ([Arg Term] -&gt; Term) -&gt; [Arg Term] -&gt; Arg Term
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">ConHead -&gt; ConInfo -&gt; [Elim] -&gt; Term
</span><a href="Agda.Syntax.Internal.html#Con"><span class="hs-identifier hs-var">Con</span></a></span><span> </span><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621681496088"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ConPatternInfo -&gt; ConInfo
</span><a href="Agda.Syntax.Internal.html#fromConPatternInfo"><span class="hs-identifier hs-var">fromConPatternInfo</span></a></span><span> </span><span class="annot"><span class="annottext">ConPatternInfo
</span><a href="#local-6989586621681496089"><span class="hs-identifier hs-var">cpi</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">([Elim] -&gt; Term) -&gt; ([Arg Term] -&gt; [Elim]) -&gt; [Arg Term] -&gt; Term
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(Arg Term -&gt; Elim) -&gt; [Arg Term] -&gt; [Elim]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Arg Term -&gt; Elim
forall a. Arg a -&gt; Elim' a
</span><a href="Agda.Syntax.Internal.Elim.html#Apply"><span class="hs-identifier hs-var">Apply</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">((Match Term, [Arg Term]) -&gt; (Match Term, Arg Term))
-&gt; m (Match Term, [Arg Term]) -&gt; m (Match Term, Arg Term)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-240"></span><span>          </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
-&gt; [Arg Term] -&gt; m (Match Term, [Arg Term])
forall (m :: * -&gt; *).
MonadMatch m =&gt;
[NamedArg DeBruijnPattern]
-&gt; [Arg Term] -&gt; m (Match Term, [Arg Term])
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchPatterns"><span class="hs-identifier hs-var">matchPatterns</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621681496090"><span class="hs-identifier hs-var">ps</span></a></span><span> </span><span class="annot"><span class="annottext">([Arg Term] -&gt; m (Match Term, [Arg Term]))
-&gt; [Arg Term] -&gt; m (Match Term, [Arg Term])
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Arg QName] -&gt; (Arg QName -&gt; Arg Term) -&gt; [Arg Term]
forall (f :: * -&gt; *) a b. Functor f =&gt; f a -&gt; (a -&gt; b) -&gt; f b
</span><a href="Agda.Utils.Functor.html#for"><span class="hs-identifier hs-var">for</span></a></span><span> </span><span class="annot"><span class="annottext">[Arg QName]
</span><a href="#local-6989586621681496098"><span class="hs-identifier hs-var">fs</span></a></span><span> </span><span class="annot"><span class="annottext">((Arg QName -&gt; Arg Term) -&gt; [Arg Term])
-&gt; (Arg QName -&gt; Arg Term) -&gt; [Arg Term]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span id="local-6989586621681496103"><span class="annot"><span class="annottext">ArgInfo
</span><a href="#local-6989586621681496103"><span class="hs-identifier hs-var">ai</span></a></span></span><span> </span><span id="local-6989586621681496104"><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621681496104"><span class="hs-identifier hs-var">f</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ArgInfo -&gt; Term -&gt; Arg Term
forall e. ArgInfo -&gt; e -&gt; Arg e
</span><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-var">Arg</span></a></span><span> </span><span class="annot"><span class="annottext">ArgInfo
</span><a href="#local-6989586621681496103"><span class="hs-identifier hs-var">ai</span></a></span><span> </span><span class="annot"><span class="annottext">(Term -&gt; Arg Term) -&gt; Term -&gt; Arg Term
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621681496092"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">Term -&gt; [Elim] -&gt; Term
forall t. Apply t =&gt; t -&gt; [Elim] -&gt; t
</span><a href="Agda.TypeChecking.Substitute.Class.html#applyE"><span class="hs-operator hs-var">`applyE`</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">ProjOrigin -&gt; QName -&gt; Elim
forall a. ProjOrigin -&gt; QName -&gt; Elim' a
</span><a href="Agda.Syntax.Internal.Elim.html#Proj"><span class="hs-identifier hs-var">Proj</span></a></span><span> </span><span class="annot"><span class="annottext">ProjOrigin
</span><a href="Agda.Syntax.Common.html#ProjSystem"><span class="hs-identifier hs-var">ProjSystem</span></a></span><span> </span><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621681496104"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-241"></span><span>    </span><span class="hs-keyword">where</span><span>
</span><span id="line-242"></span><span>    </span><span id="local-6989586621681495553"><span class="annot"><a href="#local-6989586621681496096"><span class="hs-identifier hs-type">isEtaRecordCon</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Monad.Signature.html#HasConstInfo"><span class="hs-identifier hs-type">HasConstInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681495553"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Abstract.Name.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681495553"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Abstract.Name.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span></span><span>
</span><span id="line-243"></span><span>    </span><span id="local-6989586621681496096"><span class="annot"><span class="annottext">isEtaRecordCon :: forall (m :: * -&gt; *).
HasConstInfo m =&gt;
QName -&gt; m (Maybe [Arg QName])
</span><a href="#local-6989586621681496096"><span class="hs-identifier hs-var hs-var">isEtaRecordCon</span></a></span></span><span> </span><span id="local-6989586621681496124"><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621681496124"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-244"></span><span>      </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Definition -&gt; Defn
</span><a href="Agda.TypeChecking.Monad.Base.html#theDef"><span class="hs-identifier hs-var">theDef</span></a></span><span> </span><span class="annot"><span class="annottext">(Definition -&gt; Defn) -&gt; m Definition -&gt; m Defn
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">QName -&gt; m Definition
forall (m :: * -&gt; *). HasConstInfo m =&gt; QName -&gt; m Definition
</span><a href="Agda.TypeChecking.Monad.Signature.html#getConstInfo"><span class="hs-identifier hs-var">getConstInfo</span></a></span><span> </span><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621681496124"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">m Defn -&gt; (Defn -&gt; m (Maybe [Arg QName])) -&gt; m (Maybe [Arg QName])
forall a b. m a -&gt; (a -&gt; m b) -&gt; m b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-245"></span><span>        </span><span class="annot"><a href="Agda.TypeChecking.Monad.Base.html#Constructor"><span class="hs-identifier hs-type">Constructor</span></a></span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">conData :: Defn -&gt; QName
</span><a href="Agda.TypeChecking.Monad.Base.html#conData"><span class="hs-identifier hs-var">conData</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681496129"><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621681496129"><span class="hs-identifier hs-var">d</span></a></span></span><span> </span><span class="hs-special">}</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-246"></span><span>          </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Definition -&gt; Defn
</span><a href="Agda.TypeChecking.Monad.Base.html#theDef"><span class="hs-identifier hs-var">theDef</span></a></span><span> </span><span class="annot"><span class="annottext">(Definition -&gt; Defn) -&gt; m Definition -&gt; m Defn
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">QName -&gt; m Definition
forall (m :: * -&gt; *). HasConstInfo m =&gt; QName -&gt; m Definition
</span><a href="Agda.TypeChecking.Monad.Signature.html#getConstInfo"><span class="hs-identifier hs-var">getConstInfo</span></a></span><span> </span><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621681496129"><span class="hs-identifier hs-var">d</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">m Defn -&gt; (Defn -&gt; m (Maybe [Arg QName])) -&gt; m (Maybe [Arg QName])
forall a b. m a -&gt; (a -&gt; m b) -&gt; m b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-247"></span><span>            </span><span id="local-6989586621681496130"><span class="annot"><span class="annottext">r :: Defn
</span><a href="#local-6989586621681496130"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-glyph">@</span><span class="annot"><a href="Agda.TypeChecking.Monad.Base.html#Record"><span class="hs-identifier hs-type">Record</span></a></span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">recFields :: Defn -&gt; [Dom QName]
</span><a href="Agda.TypeChecking.Monad.Base.html#recFields"><span class="hs-identifier hs-var">recFields</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681496133"><span class="annot"><span class="annottext">[Dom QName]
</span><a href="#local-6989586621681496133"><span class="hs-identifier hs-var">fs</span></a></span></span><span> </span><span class="hs-special">}</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">HasEta' PatternOrCopattern
</span><a href="Agda.Syntax.Common.html#YesEta"><span class="hs-identifier hs-var">YesEta</span></a></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Defn -&gt; HasEta' PatternOrCopattern
</span><a href="Agda.TypeChecking.Monad.Base.html#recEtaEquality"><span class="hs-identifier hs-var">recEtaEquality</span></a></span><span> </span><span class="annot"><span class="annottext">Defn
</span><a href="#local-6989586621681496130"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe [Arg QName] -&gt; m (Maybe [Arg QName])
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Maybe [Arg QName] -&gt; m (Maybe [Arg QName]))
-&gt; Maybe [Arg QName] -&gt; m (Maybe [Arg QName])
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Arg QName] -&gt; Maybe [Arg QName]
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">([Arg QName] -&gt; Maybe [Arg QName])
-&gt; [Arg QName] -&gt; Maybe [Arg QName]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Dom QName -&gt; Arg QName) -&gt; [Dom QName] -&gt; [Arg QName]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Dom QName -&gt; Arg QName
forall t a. Dom' t a -&gt; Arg a
</span><a href="Agda.Syntax.Internal.html#argFromDom"><span class="hs-identifier hs-var">argFromDom</span></a></span><span> </span><span class="annot"><span class="annottext">[Dom QName]
</span><a href="#local-6989586621681496133"><span class="hs-identifier hs-var">fs</span></a></span><span>
</span><span id="line-248"></span><span>            </span><span class="annot"><span class="annottext">Defn
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe [Arg QName] -&gt; m (Maybe [Arg QName])
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Maybe [Arg QName]
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-249"></span><span>        </span><span class="annot"><span class="annottext">Defn
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Maybe [Arg QName])
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span>
</span><span id="line-250"></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#DefP"><span class="hs-identifier hs-type">DefP</span></a></span><span> </span><span id="local-6989586621681496138"><span class="annot"><span class="annottext">PatternInfo
</span><a href="#local-6989586621681496138"><span class="hs-identifier hs-var">o</span></a></span></span><span> </span><span id="local-6989586621681496139"><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621681496139"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span id="local-6989586621681496140"><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621681496140"><span class="hs-identifier hs-var">ps</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681496141"><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621681496141"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-251"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621681496142"><span class="annot"><span class="annottext">f :: Term -&gt; Maybe ([Elim] -&gt; Term, [Elim])
</span><a href="#local-6989586621681496142"><span class="hs-identifier hs-var hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#Def"><span class="hs-identifier hs-type">Def</span></a></span><span> </span><span id="local-6989586621681496144"><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621681496144"><span class="hs-identifier hs-var">q'</span></a></span></span><span> </span><span id="local-6989586621681496145"><span class="annot"><span class="annottext">[Elim]
</span><a href="#local-6989586621681496145"><span class="hs-identifier hs-var">vs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621681496139"><span class="hs-identifier hs-var">q</span></a></span><span> </span><span class="annot"><span class="annottext">QName -&gt; QName -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621681496144"><span class="hs-identifier hs-var">q'</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">([Elim] -&gt; Term, [Elim]) -&gt; Maybe ([Elim] -&gt; Term, [Elim])
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">QName -&gt; [Elim] -&gt; Term
</span><a href="Agda.Syntax.Internal.html#Def"><span class="hs-identifier hs-var">Def</span></a></span><span> </span><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621681496139"><span class="hs-identifier hs-var">q</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Elim]
</span><a href="#local-6989586621681496145"><span class="hs-identifier hs-var">vs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-252"></span><span>        </span><span class="annot"><a href="#local-6989586621681496142"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span>                     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe ([Elim] -&gt; Term, [Elim])
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-253"></span><span>    </span><span class="annot"><span class="annottext">(Term -&gt; Maybe ([Elim] -&gt; Term, [Elim]))
-&gt; [NamedArg DeBruijnPattern]
-&gt; Arg Term
-&gt; m (Match Term, Arg Term)
forall (m :: * -&gt; *).
MonadMatch m =&gt;
(Term -&gt; Maybe ([Elim] -&gt; Term, [Elim]))
-&gt; [NamedArg DeBruijnPattern]
-&gt; Arg Term
-&gt; m (Match Term, Arg Term)
</span><a href="#local-6989586621681496146"><span class="hs-identifier hs-var">fallback'</span></a></span><span> </span><span class="annot"><span class="annottext">Term -&gt; Maybe ([Elim] -&gt; Term, [Elim])
</span><a href="#local-6989586621681496142"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621681496140"><span class="hs-identifier hs-var">ps</span></a></span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621681496141"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-254"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-255"></span><span>    </span><span class="hs-comment">-- Default: not an eta record constructor.</span><span>
</span><span id="line-256"></span><span>  </span><span id="local-6989586621681495551"><span class="annot"><a href="#local-6989586621681496095"><span class="hs-identifier hs-type">fallback</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#MonadMatch"><span class="hs-identifier hs-type">MonadMatch</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681495551"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-257"></span><span>           </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#ConHead"><span class="hs-identifier hs-type">ConHead</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Common.html#NamedArg"><span class="hs-identifier hs-type">NamedArg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#DeBruijnPattern"><span class="hs-identifier hs-type">DeBruijnPattern</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681495551"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-258"></span><span>  </span><span id="local-6989586621681496095"><span class="annot"><span class="annottext">fallback :: forall (m :: * -&gt; *).
MonadMatch m =&gt;
ConHead
-&gt; [NamedArg DeBruijnPattern]
-&gt; Arg Term
-&gt; m (Match Term, Arg Term)
</span><a href="#local-6989586621681496095"><span class="hs-identifier hs-var hs-var">fallback</span></a></span></span><span> </span><span id="local-6989586621681496151"><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621681496151"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621681496152"><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621681496152"><span class="hs-identifier hs-var">ps</span></a></span></span><span> </span><span id="local-6989586621681496153"><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621681496153"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-259"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621681496154"><span class="annot"><span class="annottext">f :: Term -&gt; Maybe ([Elim] -&gt; Term, [Elim])
</span><a href="#local-6989586621681496154"><span class="hs-identifier hs-var hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#Con"><span class="hs-identifier hs-type">Con</span></a></span><span> </span><span id="local-6989586621681496155"><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621681496155"><span class="hs-identifier hs-var">c'</span></a></span></span><span> </span><span id="local-6989586621681496156"><span class="annot"><span class="annottext">ConInfo
</span><a href="#local-6989586621681496156"><span class="hs-identifier hs-var">ci'</span></a></span></span><span> </span><span id="local-6989586621681496157"><span class="annot"><span class="annottext">[Elim]
</span><a href="#local-6989586621681496157"><span class="hs-identifier hs-var">vs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621681496151"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">ConHead -&gt; ConHead -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621681496155"><span class="hs-identifier hs-var">c'</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">([Elim] -&gt; Term, [Elim]) -&gt; Maybe ([Elim] -&gt; Term, [Elim])
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ConHead -&gt; ConInfo -&gt; [Elim] -&gt; Term
</span><a href="Agda.Syntax.Internal.html#Con"><span class="hs-identifier hs-var">Con</span></a></span><span> </span><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621681496155"><span class="hs-identifier hs-var">c'</span></a></span><span> </span><span class="annot"><span class="annottext">ConInfo
</span><a href="#local-6989586621681496156"><span class="hs-identifier hs-var">ci'</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">[Elim]
</span><a href="#local-6989586621681496157"><span class="hs-identifier hs-var">vs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-260"></span><span>        </span><span class="annot"><a href="#local-6989586621681496154"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span>                         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe ([Elim] -&gt; Term, [Elim])
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-261"></span><span>    </span><span class="annot"><span class="annottext">(Term -&gt; Maybe ([Elim] -&gt; Term, [Elim]))
-&gt; [NamedArg DeBruijnPattern]
-&gt; Arg Term
-&gt; m (Match Term, Arg Term)
forall (m :: * -&gt; *).
MonadMatch m =&gt;
(Term -&gt; Maybe ([Elim] -&gt; Term, [Elim]))
-&gt; [NamedArg DeBruijnPattern]
-&gt; Arg Term
-&gt; m (Match Term, Arg Term)
</span><a href="#local-6989586621681496146"><span class="hs-identifier hs-var">fallback'</span></a></span><span> </span><span class="annot"><span class="annottext">Term -&gt; Maybe ([Elim] -&gt; Term, [Elim])
</span><a href="#local-6989586621681496154"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621681496152"><span class="hs-identifier hs-var">ps</span></a></span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621681496153"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-262"></span><span>
</span><span id="line-263"></span><span>  </span><span class="hs-comment">-- Regardless of blocking, constructors and a properly applied @hcomp@</span><span>
</span><span id="line-264"></span><span>  </span><span class="hs-comment">-- can be matched on.</span><span>
</span><span id="line-265"></span><span>  </span><span id="local-6989586621681495573"><span class="annot"><a href="#local-6989586621681496158"><span class="hs-identifier hs-type">isMatchable'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Monad.Builtin.html#HasBuiltins"><span class="hs-identifier hs-type">HasBuiltins</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681495573"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681495573"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#Blocked"><span class="hs-identifier hs-type">Blocked</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-266"></span><span>  </span><span id="local-6989586621681496158"><span class="annot"><span class="annottext">isMatchable' :: forall (m :: * -&gt; *).
HasBuiltins m =&gt;
m (Blocked Term -&gt; Maybe Term)
</span><a href="#local-6989586621681496158"><span class="hs-identifier hs-var hs-var">isMatchable'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-267"></span><span>    </span><span class="hs-special">[</span><span id="local-6989586621681496175"><span class="annot"><span class="annottext">Maybe QName
</span><a href="#local-6989586621681496175"><span class="hs-identifier hs-var">mhcomp</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621681496176"><span class="annot"><span class="annottext">Maybe QName
</span><a href="#local-6989586621681496176"><span class="hs-identifier hs-var">mconid</span></a></span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(PrimitiveId -&gt; m (Maybe QName))
-&gt; [PrimitiveId] -&gt; m [Maybe QName]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; [a] -&gt; m [b]
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="annot"><span class="annottext">PrimitiveId -&gt; m (Maybe QName)
forall (m :: * -&gt; *) a.
(HasBuiltins m, IsBuiltin a) =&gt;
a -&gt; m (Maybe QName)
</span><a href="Agda.TypeChecking.Monad.Builtin.html#getName%27"><span class="hs-identifier hs-var">getName'</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">PrimitiveId
</span><a href="Agda.Syntax.Builtin.html#builtinHComp"><span class="hs-identifier hs-var">builtinHComp</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">PrimitiveId
</span><a href="Agda.Syntax.Builtin.html#builtinConId"><span class="hs-identifier hs-var">builtinConId</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-268"></span><span>    </span><span class="annot"><span class="annottext">(Blocked Term -&gt; Maybe Term) -&gt; m (Blocked Term -&gt; Maybe Term)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">((Blocked Term -&gt; Maybe Term) -&gt; m (Blocked Term -&gt; Maybe Term))
-&gt; (Blocked Term -&gt; Maybe Term) -&gt; m (Blocked Term -&gt; Maybe Term)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621681496178"><span class="annot"><span class="annottext">Blocked Term
</span><a href="#local-6989586621681496178"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-269"></span><span>      </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Blocked Term -&gt; Term
forall t a. Blocked' t a -&gt; a
</span><a href="Agda.Syntax.Internal.Blockers.html#ignoreBlocking"><span class="hs-identifier hs-var">ignoreBlocking</span></a></span><span> </span><span class="annot"><span class="annottext">Blocked Term
</span><a href="#local-6989586621681496178"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-270"></span><span>        </span><span id="local-6989586621681496179"><span class="annot"><span class="annottext">t :: Term
</span><a href="#local-6989586621681496179"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-glyph">@</span><span class="annot"><a href="Agda.Syntax.Internal.html#Con"><span class="hs-identifier hs-type">Con</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Term -&gt; Maybe Term
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621681496179"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-271"></span><span>        </span><span id="local-6989586621681496180"><span class="annot"><span class="annottext">t :: Term
</span><a href="#local-6989586621681496180"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#Def"><span class="hs-identifier hs-type">Def</span></a></span><span> </span><span id="local-6989586621681496181"><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621681496181"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span class="hs-special">[</span><span id="local-6989586621681496182"><span class="annot"><span class="annottext">Elim
</span><a href="#local-6989586621681496182"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621681496183"><span class="annot"><span class="annottext">Elim
</span><a href="#local-6989586621681496183"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621681496184"><span class="annot"><span class="annottext">Elim
</span><a href="#local-6989586621681496184"><span class="hs-identifier hs-var">phi</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621681496185"><span class="annot"><span class="annottext">Elim
</span><a href="#local-6989586621681496185"><span class="hs-identifier hs-var">u</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621681496186"><span class="annot"><span class="annottext">Elim
</span><a href="#local-6989586621681496186"><span class="hs-identifier hs-var">u0</span></a></span></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">QName -&gt; Maybe QName
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621681496181"><span class="hs-identifier hs-var">q</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe QName -&gt; Maybe QName -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Maybe QName
</span><a href="#local-6989586621681496175"><span class="hs-identifier hs-var">mhcomp</span></a></span><span>
</span><span id="line-272"></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Term -&gt; Maybe Term
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621681496180"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-273"></span><span>        </span><span id="local-6989586621681496187"><span class="annot"><span class="annottext">t :: Term
</span><a href="#local-6989586621681496187"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#Def"><span class="hs-identifier hs-type">Def</span></a></span><span> </span><span id="local-6989586621681496188"><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621681496188"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span class="hs-special">[</span><span id="local-6989586621681496189"><span class="annot"><span class="annottext">Elim
</span><a href="#local-6989586621681496189"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621681496190"><span class="annot"><span class="annottext">Elim
</span><a href="#local-6989586621681496190"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621681496191"><span class="annot"><span class="annottext">Elim
</span><a href="#local-6989586621681496191"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621681496192"><span class="annot"><span class="annottext">Elim
</span><a href="#local-6989586621681496192"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621681496193"><span class="annot"><span class="annottext">Elim
</span><a href="#local-6989586621681496193"><span class="hs-identifier hs-var">phi</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621681496194"><span class="annot"><span class="annottext">Elim
</span><a href="#local-6989586621681496194"><span class="hs-identifier hs-var">p</span></a></span></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">QName -&gt; Maybe QName
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621681496188"><span class="hs-identifier hs-var">q</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe QName -&gt; Maybe QName -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Maybe QName
</span><a href="#local-6989586621681496176"><span class="hs-identifier hs-var">mconid</span></a></span><span>
</span><span id="line-274"></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Term -&gt; Maybe Term
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621681496187"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-275"></span><span>        </span><span class="hs-comment">-- TODO this covers the transpIx functions, but it's a hack.</span><span>
</span><span id="line-276"></span><span>        </span><span id="local-6989586621681496195"><span class="annot"><span class="annottext">t :: Term
</span><a href="#local-6989586621681496195"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#Def"><span class="hs-identifier hs-type">Def</span></a></span><span> </span><span id="local-6989586621681496196"><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621681496196"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span class="annot"><span class="annottext">[Elim]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.Blockers.html#NotBlocked"><span class="hs-identifier hs-type">NotBlocked</span></a></span><span class="hs-special">{</span><span class="annot"><span class="annottext">blockingStatus :: forall t a. Blocked' t a -&gt; NotBlocked' t
</span><a href="Agda.Syntax.Internal.Blockers.html#blockingStatus"><span class="hs-identifier hs-var">blockingStatus</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.Blockers.html#MissingClauses"><span class="hs-identifier hs-type">MissingClauses</span></a></span><span> </span><span class="annot"><span class="annottext">QName
</span><span class="hs-identifier">_</span></span><span class="hs-special">}</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Blocked Term
</span><a href="#local-6989586621681496178"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Term -&gt; Maybe Term
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621681496195"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-277"></span><span>        </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe Term
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-278"></span><span>
</span><span id="line-279"></span><span>  </span><span class="hs-comment">-- DefP hcomp and ConP matching.</span><span>
</span><span id="line-280"></span><span>  </span><span id="local-6989586621681495571"><span class="annot"><a href="#local-6989586621681496146"><span class="hs-identifier hs-type">fallback'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#MonadMatch"><span class="hs-identifier hs-type">MonadMatch</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681495571"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-281"></span><span>            </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#Elims"><span class="hs-identifier hs-type">Elims</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span> </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Elims"><span class="hs-identifier hs-type">Elims</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-282"></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Common.html#NamedArg"><span class="hs-identifier hs-type">NamedArg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#DeBruijnPattern"><span class="hs-identifier hs-type">DeBruijnPattern</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-283"></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span>
</span><span id="line-284"></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681495571"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-285"></span><span>  </span><span id="local-6989586621681496146"><span class="annot"><span class="annottext">fallback' :: forall (m :: * -&gt; *).
MonadMatch m =&gt;
(Term -&gt; Maybe ([Elim] -&gt; Term, [Elim]))
-&gt; [NamedArg DeBruijnPattern]
-&gt; Arg Term
-&gt; m (Match Term, Arg Term)
</span><a href="#local-6989586621681496146"><span class="hs-identifier hs-var hs-var">fallback'</span></a></span></span><span> </span><span id="local-6989586621681496227"><span class="annot"><span class="annottext">Term -&gt; Maybe ([Elim] -&gt; Term, [Elim])
</span><a href="#local-6989586621681496227"><span class="hs-identifier hs-var">mtc</span></a></span></span><span> </span><span id="local-6989586621681496228"><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621681496228"><span class="hs-identifier hs-var">ps</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span id="local-6989586621681496229"><span class="annot"><span class="annottext">ArgInfo
</span><a href="#local-6989586621681496229"><span class="hs-identifier hs-var">info</span></a></span></span><span> </span><span id="local-6989586621681496230"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621681496230"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-286"></span><span>        </span><span id="local-6989586621681496231"><span class="annot"><span class="annottext">Blocked Term -&gt; Maybe Term
</span><a href="#local-6989586621681496231"><span class="hs-identifier hs-var">isMatchable</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">m (Blocked Term -&gt; Maybe Term)
forall (m :: * -&gt; *).
HasBuiltins m =&gt;
m (Blocked Term -&gt; Maybe Term)
</span><a href="#local-6989586621681496158"><span class="hs-identifier hs-var">isMatchable'</span></a></span><span>
</span><span id="line-287"></span><span>
</span><span id="line-288"></span><span>        </span><span id="local-6989586621681496232"><span class="annot"><span class="annottext">Blocked Term
</span><a href="#local-6989586621681496232"><span class="hs-identifier hs-var">w</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Term -&gt; m (Blocked Term)
forall a (m :: * -&gt; *).
(Reduce a, MonadReduce m) =&gt;
a -&gt; m (Blocked a)
</span><a href="Agda.TypeChecking.Reduce.html#reduceB"><span class="hs-identifier hs-var">reduceB</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621681496230"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-289"></span><span>        </span><span class="hs-comment">-- Unfold delayed (corecursive) definitions one step. This is</span><span>
</span><span id="line-290"></span><span>        </span><span class="hs-comment">-- only necessary if c is a coinductive constructor, but</span><span>
</span><span id="line-291"></span><span>        </span><span class="hs-comment">-- it does not hurt to do it all the time.</span><span>
</span><span id="line-292"></span><span class="hs-comment">{-
        w &lt;- case w of
               NotBlocked r (Def f es) -&gt;   -- Andreas, 2014-06-12 TODO: r == ReallyNotBlocked sufficient?
                 unfoldDefinitionE True reduceB' (Def f []) f es
                   -- reduceB is used here because some constructors
                   -- are actually definitions which need to be
                   -- unfolded (due to open public).
               _ -&gt; return w
-}</span><span>
</span><span id="line-301"></span><span>        </span><span class="hs-comment">-- Jesper, 23-06-2016: Note that unfoldCorecursion may destroy</span><span>
</span><span id="line-302"></span><span>        </span><span class="hs-comment">-- constructor forms, so we only call constructorForm after.</span><span>
</span><span id="line-303"></span><span>        </span><span id="local-6989586621681496233"><span class="annot"><span class="annottext">Blocked Term
</span><a href="#local-6989586621681496233"><span class="hs-identifier hs-var">w</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(Term -&gt; m Term) -&gt; Blocked Term -&gt; m (Blocked Term)
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable t, Applicative f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Blocked' Term a -&gt; f (Blocked' Term b)
</span><span class="hs-identifier hs-var">traverse</span></span><span> </span><span class="annot"><span class="annottext">Term -&gt; m Term
forall (m :: * -&gt; *). HasBuiltins m =&gt; Term -&gt; m Term
</span><a href="Agda.TypeChecking.Reduce.Monad.html#constructorForm"><span class="hs-identifier hs-var">constructorForm</span></a></span><span> </span><span class="annot"><span class="annottext">(Blocked Term -&gt; m (Blocked Term))
-&gt; m (Blocked Term) -&gt; m (Blocked Term)
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
</span><span class="hs-operator hs-var">=&lt;&lt;</span></span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Blocked Term
</span><a href="#local-6989586621681496232"><span class="hs-identifier hs-var">w</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-304"></span><span>               </span><span class="annot"><a href="Agda.Syntax.Internal.Blockers.html#NotBlocked"><span class="hs-identifier hs-type">NotBlocked</span></a></span><span> </span><span id="local-6989586621681496237"><span class="annot"><span class="annottext">NotBlocked' Term
</span><a href="#local-6989586621681496237"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span id="local-6989586621681496238"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621681496238"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ReduceM (Blocked Term) -&gt; m (Blocked Term)
forall a. ReduceM a -&gt; m a
forall (m :: * -&gt; *) a. MonadReduce m =&gt; ReduceM a -&gt; m a
</span><a href="Agda.TypeChecking.Monad.Base.html#liftReduce"><span class="hs-identifier hs-var">liftReduce</span></a></span><span> </span><span class="annot"><span class="annottext">(ReduceM (Blocked Term) -&gt; m (Blocked Term))
-&gt; ReduceM (Blocked Term) -&gt; m (Blocked Term)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Term -&gt; ReduceM (Blocked Term)
</span><a href="Agda.TypeChecking.Reduce.html#unfoldCorecursion"><span class="hs-identifier hs-var">unfoldCorecursion</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621681496238"><span class="hs-identifier hs-var">u</span></a></span><span>  </span><span class="hs-comment">-- Andreas, 2014-06-12 TODO: r == ReallyNotBlocked sufficient?</span><span>
</span><span id="line-305"></span><span>               </span><span class="annot"><span class="annottext">Blocked Term
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Blocked Term -&gt; m (Blocked Term)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Blocked Term
</span><a href="#local-6989586621681496232"><span class="hs-identifier hs-var">w</span></a></span><span>
</span><span id="line-306"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621681496241"><span class="annot"><span class="annottext">v :: Term
</span><a href="#local-6989586621681496241"><span class="hs-identifier hs-var hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Blocked Term -&gt; Term
forall t a. Blocked' t a -&gt; a
</span><a href="Agda.Syntax.Internal.Blockers.html#ignoreBlocking"><span class="hs-identifier hs-var">ignoreBlocking</span></a></span><span> </span><span class="annot"><span class="annottext">Blocked Term
</span><a href="#local-6989586621681496233"><span class="hs-identifier hs-var">w</span></a></span><span>
</span><span id="line-307"></span><span>            </span><span id="local-6989586621681496242"><span class="annot"><span class="annottext">arg :: Arg Term
</span><a href="#local-6989586621681496242"><span class="hs-identifier hs-var hs-var">arg</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ArgInfo -&gt; Term -&gt; Arg Term
forall e. ArgInfo -&gt; e -&gt; Arg e
</span><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-var">Arg</span></a></span><span> </span><span class="annot"><span class="annottext">ArgInfo
</span><a href="#local-6989586621681496229"><span class="hs-identifier hs-var">info</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621681496241"><span class="hs-identifier hs-var">v</span></a></span><span>  </span><span class="hs-comment">-- the reduced argument</span><span>
</span><span id="line-308"></span><span>
</span><span id="line-309"></span><span>        </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Blocked Term
</span><a href="#local-6989586621681496233"><span class="hs-identifier hs-var">w</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-310"></span><span>          </span><span id="local-6989586621681496243"><span class="annot"><span class="annottext">Blocked Term
</span><a href="#local-6989586621681496243"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621681496244"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621681496244"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Blocked Term -&gt; Maybe Term
</span><a href="#local-6989586621681496231"><span class="hs-identifier hs-var">isMatchable</span></a></span><span> </span><span class="annot"><span class="annottext">Blocked Term
</span><a href="#local-6989586621681496243"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-311"></span><span>            </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Term -&gt; Maybe ([Elim] -&gt; Term, [Elim])
</span><a href="#local-6989586621681496227"><span class="hs-identifier hs-var">mtc</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621681496244"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-312"></span><span>              </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621681496245"><span class="annot"><span class="annottext">[Elim] -&gt; Term
</span><a href="#local-6989586621681496245"><span class="hs-identifier hs-var">bld</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681496246"><span class="annot"><span class="annottext">[Elim]
</span><a href="#local-6989586621681496246"><span class="hs-identifier hs-var">vs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-313"></span><span>                </span><span class="hs-special">(</span><span id="local-6989586621681496247"><span class="annot"><span class="annottext">Match Term
</span><a href="#local-6989586621681496247"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681496248"><span class="annot"><span class="annottext">[Arg Term]
</span><a href="#local-6989586621681496248"><span class="hs-identifier hs-var">vs1</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
-&gt; [Arg Term] -&gt; m (Match Term, [Arg Term])
forall (m :: * -&gt; *).
MonadMatch m =&gt;
[NamedArg DeBruijnPattern]
-&gt; [Arg Term] -&gt; m (Match Term, [Arg Term])
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchPatterns"><span class="hs-identifier hs-var">matchPatterns</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621681496228"><span class="hs-identifier hs-var">ps</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Arg Term] -&gt; Maybe [Arg Term] -&gt; [Arg Term]
forall a. a -&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromMaybe</span></span><span> </span><span class="annot"><span class="annottext">[Arg Term]
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span> </span><span class="annot"><span class="annottext">(Maybe [Arg Term] -&gt; [Arg Term]) -&gt; Maybe [Arg Term] -&gt; [Arg Term]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Elim] -&gt; Maybe [Arg Term]
forall a. [Elim' a] -&gt; Maybe [Arg a]
</span><a href="Agda.Syntax.Internal.Elim.html#allApplyElims"><span class="hs-identifier hs-var">allApplyElims</span></a></span><span> </span><span class="annot"><span class="annottext">[Elim]
</span><a href="#local-6989586621681496246"><span class="hs-identifier hs-var">vs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-314"></span><span>                </span><span class="annot"><span class="annottext">(Match Term, Arg Term) -&gt; m (Match Term, Arg Term)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Match Term -&gt; Match Term
forall a. Match a -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#yesSimplification"><span class="hs-identifier hs-var">yesSimplification</span></a></span><span> </span><span class="annot"><span class="annottext">Match Term
</span><a href="#local-6989586621681496247"><span class="hs-identifier hs-var">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ArgInfo -&gt; Term -&gt; Arg Term
forall e. ArgInfo -&gt; e -&gt; Arg e
</span><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-var">Arg</span></a></span><span> </span><span class="annot"><span class="annottext">ArgInfo
</span><a href="#local-6989586621681496229"><span class="hs-identifier hs-var">info</span></a></span><span> </span><span class="annot"><span class="annottext">(Term -&gt; Arg Term) -&gt; Term -&gt; Arg Term
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Elim] -&gt; Term
</span><a href="#local-6989586621681496245"><span class="hs-identifier hs-var">bld</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Elim] -&gt; [Arg Term] -&gt; [Elim]
</span><a href="Agda.TypeChecking.Patterns.Match.html#mergeElims"><span class="hs-identifier hs-var">mergeElims</span></a></span><span> </span><span class="annot"><span class="annottext">[Elim]
</span><a href="#local-6989586621681496246"><span class="hs-identifier hs-var">vs</span></a></span><span> </span><span class="annot"><span class="annottext">[Arg Term]
</span><a href="#local-6989586621681496248"><span class="hs-identifier hs-var">vs1</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-315"></span><span>              </span><span class="annot"><span class="annottext">Maybe ([Elim] -&gt; Term, [Elim])
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-316"></span><span>                                    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Match Term, Arg Term) -&gt; m (Match Term, Arg Term)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Match Term
forall a. Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span><span>                          </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621681496242"><span class="hs-identifier hs-var">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-317"></span><span>          </span><span class="annot"><a href="Agda.Syntax.Internal.Blockers.html#Blocked"><span class="hs-identifier hs-type">Blocked</span></a></span><span> </span><span id="local-6989586621681496251"><span class="annot"><span class="annottext">Blocker
</span><a href="#local-6989586621681496251"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Match Term, Arg Term) -&gt; m (Match Term, Arg Term)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Blocked () -&gt; Match Term
forall a. Blocked () -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#DontKnow"><span class="hs-identifier hs-var">DontKnow</span></a></span><span> </span><span class="annot"><span class="annottext">(Blocked () -&gt; Match Term) -&gt; Blocked () -&gt; Match Term
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Blocker -&gt; () -&gt; Blocked ()
forall t a. Blocker -&gt; a -&gt; Blocked' t a
</span><a href="Agda.Syntax.Internal.Blockers.html#Blocked"><span class="hs-identifier hs-var">Blocked</span></a></span><span> </span><span class="annot"><span class="annottext">Blocker
</span><a href="#local-6989586621681496251"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>     </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621681496242"><span class="hs-identifier hs-var">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-318"></span><span>          </span><span class="annot"><a href="Agda.Syntax.Internal.Blockers.html#NotBlocked"><span class="hs-identifier hs-type">NotBlocked</span></a></span><span> </span><span id="local-6989586621681496252"><span class="annot"><span class="annottext">NotBlocked' Term
</span><a href="#local-6989586621681496252"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Match Term, Arg Term) -&gt; m (Match Term, Arg Term)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Blocked () -&gt; Match Term
forall a. Blocked () -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#DontKnow"><span class="hs-identifier hs-var">DontKnow</span></a></span><span> </span><span class="annot"><span class="annottext">(Blocked () -&gt; Match Term) -&gt; Blocked () -&gt; Match Term
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">NotBlocked' Term -&gt; () -&gt; Blocked ()
forall t a. NotBlocked' t -&gt; a -&gt; Blocked' t a
</span><a href="Agda.Syntax.Internal.Blockers.html#NotBlocked"><span class="hs-identifier hs-var">NotBlocked</span></a></span><span> </span><span class="annot"><span class="annottext">NotBlocked' Term
</span><a href="#local-6989586621681496253"><span class="hs-identifier hs-var">r'</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621681496242"><span class="hs-identifier hs-var">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-319"></span><span>            </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621681496253"><span class="annot"><span class="annottext">r' :: NotBlocked' Term
</span><a href="#local-6989586621681496253"><span class="hs-identifier hs-var hs-var">r'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Elim -&gt; NotBlocked' Term -&gt; NotBlocked' Term
forall t. Elim' t -&gt; NotBlocked' t -&gt; NotBlocked' t
</span><a href="Agda.Syntax.Internal.Blockers.html#stuckOn"><span class="hs-identifier hs-var">stuckOn</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Arg Term -&gt; Elim
forall a. Arg a -&gt; Elim' a
</span><a href="Agda.Syntax.Internal.Elim.html#Apply"><span class="hs-identifier hs-var">Apply</span></a></span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621681496242"><span class="hs-identifier hs-var">arg</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">NotBlocked' Term
</span><a href="#local-6989586621681496252"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-320"></span><span>
</span><span id="line-321"></span><span id="local-6989586621681495599"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#yesSimplification"><span class="hs-identifier hs-type">yesSimplification</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681495599"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681495599"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-322"></span><span id="yesSimplification"><span class="annot"><span class="annottext">yesSimplification :: forall a. Match a -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#yesSimplification"><span class="hs-identifier hs-var hs-var">yesSimplification</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-323"></span><span>  </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Yes"><span class="hs-identifier hs-type">Yes</span></a></span><span> </span><span class="annot"><span class="annottext">Simplification
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681496254"><span class="annot"><span class="annottext">IntMap (Arg a)
</span><a href="#local-6989586621681496254"><span class="hs-identifier hs-var">vs</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Simplification -&gt; IntMap (Arg a) -&gt; Match a
forall a. Simplification -&gt; IntMap (Arg a) -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#Yes"><span class="hs-identifier hs-var">Yes</span></a></span><span> </span><span class="annot"><span class="annottext">Simplification
</span><a href="Agda.TypeChecking.Monad.Base.html#YesSimplification"><span class="hs-identifier hs-var">YesSimplification</span></a></span><span> </span><span class="annot"><span class="annottext">IntMap (Arg a)
</span><a href="#local-6989586621681496254"><span class="hs-identifier hs-var">vs</span></a></span><span>
</span><span id="line-324"></span><span>  </span><span id="local-6989586621681496255"><span class="annot"><span class="annottext">Match a
</span><a href="#local-6989586621681496255"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Match a
</span><a href="#local-6989586621681496255"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-325"></span><span>
</span><span id="line-326"></span><span class="hs-comment">-- Matching patterns against patterns -------------------------------------</span><span>
</span><span id="line-327"></span><span>
</span><span id="line-328"></span><span class="annot"><span class="hs-comment">-- | Match a single pattern.</span></span><span>
</span><span id="line-329"></span><span id="local-6989586621681495601"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#matchPatternP"><span class="hs-identifier hs-type">matchPatternP</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#MonadMatch"><span class="hs-identifier hs-type">MonadMatch</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681495601"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-330"></span><span>              </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#DeBruijnPattern"><span class="hs-identifier hs-type">DeBruijnPattern</span></a></span><span>
</span><span id="line-331"></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#DeBruijnPattern"><span class="hs-identifier hs-type">DeBruijnPattern</span></a></span><span>
</span><span id="line-332"></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681495601"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#DeBruijnPattern"><span class="hs-identifier hs-type">DeBruijnPattern</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-333"></span><span id="matchPatternP"><span class="annot"><span class="annottext">matchPatternP :: forall (m :: * -&gt; *).
MonadMatch m =&gt;
DeBruijnPattern -&gt; Arg DeBruijnPattern -&gt; m (Match DeBruijnPattern)
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchPatternP"><span class="hs-identifier hs-var hs-var">matchPatternP</span></a></span></span><span> </span><span id="local-6989586621681496283"><span class="annot"><span class="annottext">DeBruijnPattern
</span><a href="#local-6989586621681496283"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span id="local-6989586621681496284"><span class="annot"><span class="annottext">ArgInfo
</span><a href="#local-6989586621681496284"><span class="hs-identifier hs-var">info</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#DotP"><span class="hs-identifier hs-type">DotP</span></a></span><span> </span><span class="annot"><span class="annottext">PatternInfo
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681496285"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621681496285"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-334"></span><span>  </span><span class="hs-special">(</span><span id="local-6989586621681496286"><span class="annot"><span class="annottext">Match Term
</span><a href="#local-6989586621681496286"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681496287"><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621681496287"><span class="hs-identifier hs-var">arg</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">DeBruijnPattern -&gt; Arg Term -&gt; m (Match Term, Arg Term)
forall (m :: * -&gt; *).
MonadMatch m =&gt;
DeBruijnPattern -&gt; Arg Term -&gt; m (Match Term, Arg Term)
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchPattern"><span class="hs-identifier hs-var">matchPattern</span></a></span><span> </span><span class="annot"><span class="annottext">DeBruijnPattern
</span><a href="#local-6989586621681496283"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ArgInfo -&gt; Term -&gt; Arg Term
forall e. ArgInfo -&gt; e -&gt; Arg e
</span><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-var">Arg</span></a></span><span> </span><span class="annot"><span class="annottext">ArgInfo
</span><a href="#local-6989586621681496284"><span class="hs-identifier hs-var">info</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621681496285"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-335"></span><span>  </span><span class="annot"><span class="annottext">Match DeBruijnPattern -&gt; m (Match DeBruijnPattern)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Match DeBruijnPattern -&gt; m (Match DeBruijnPattern))
-&gt; Match DeBruijnPattern -&gt; m (Match DeBruijnPattern)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Term -&gt; DeBruijnPattern) -&gt; Match Term -&gt; Match DeBruijnPattern
forall a b. (a -&gt; b) -&gt; Match a -&gt; Match b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">PatternInfo -&gt; Term -&gt; DeBruijnPattern
forall x. PatternInfo -&gt; Term -&gt; Pattern' x
</span><a href="Agda.Syntax.Internal.html#DotP"><span class="hs-identifier hs-var">DotP</span></a></span><span> </span><span class="annot"><span class="annottext">PatternInfo
</span><a href="Agda.Syntax.Internal.html#defaultPatternInfo"><span class="hs-identifier hs-var">defaultPatternInfo</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Match Term
</span><a href="#local-6989586621681496286"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-336"></span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#matchPatternP"><span class="hs-identifier hs-var">matchPatternP</span></a></span><span> </span><span id="local-6989586621681496289"><span class="annot"><span class="annottext">DeBruijnPattern
</span><a href="#local-6989586621681496289"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621681496290"><span class="annot"><span class="annottext">arg :: Arg DeBruijnPattern
</span><a href="#local-6989586621681496290"><span class="hs-identifier hs-var">arg</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span id="local-6989586621681496291"><span class="annot"><span class="annottext">ArgInfo
</span><a href="#local-6989586621681496291"><span class="hs-identifier hs-var">info</span></a></span></span><span> </span><span id="local-6989586621681496292"><span class="annot"><span class="annottext">DeBruijnPattern
</span><a href="#local-6989586621681496292"><span class="hs-identifier hs-var">q</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-337"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621681496293"><span class="annot"><span class="annottext">varMatch :: DBPatVar -&gt; m (Match DeBruijnPattern)
</span><a href="#local-6989586621681496293"><span class="hs-identifier hs-var hs-var">varMatch</span></a></span></span><span> </span><span id="local-6989586621681496294"><span class="annot"><span class="annottext">DBPatVar
</span><a href="#local-6989586621681496294"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Match DeBruijnPattern -&gt; m (Match DeBruijnPattern)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Match DeBruijnPattern -&gt; m (Match DeBruijnPattern))
-&gt; Match DeBruijnPattern -&gt; m (Match DeBruijnPattern)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Simplification
-&gt; IntMap (Arg DeBruijnPattern) -&gt; Match DeBruijnPattern
forall a. Simplification -&gt; IntMap (Arg a) -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#Yes"><span class="hs-identifier hs-var">Yes</span></a></span><span> </span><span class="annot"><span class="annottext">Simplification
</span><a href="Agda.TypeChecking.Monad.Base.html#NoSimplification"><span class="hs-identifier hs-var">NoSimplification</span></a></span><span> </span><span class="annot"><span class="annottext">(IntMap (Arg DeBruijnPattern) -&gt; Match DeBruijnPattern)
-&gt; IntMap (Arg DeBruijnPattern) -&gt; Match DeBruijnPattern
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Int, Arg DeBruijnPattern) -&gt; IntMap (Arg DeBruijnPattern)
forall el coll. Singleton el coll =&gt; el -&gt; coll
</span><a href="Agda.Utils.Singleton.html#singleton"><span class="hs-identifier hs-var">singleton</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DBPatVar -&gt; Int
</span><a href="Agda.Syntax.Internal.html#dbPatVarIndex"><span class="hs-identifier hs-var">dbPatVarIndex</span></a></span><span> </span><span class="annot"><span class="annottext">DBPatVar
</span><a href="#local-6989586621681496294"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Arg DeBruijnPattern
</span><a href="#local-6989586621681496290"><span class="hs-identifier hs-var">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-338"></span><span>      </span><span id="local-6989586621681496295"><span class="annot"><span class="annottext">termMatch :: m (Match DeBruijnPattern)
</span><a href="#local-6989586621681496295"><span class="hs-identifier hs-var hs-var">termMatch</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-339"></span><span>        </span><span class="hs-special">(</span><span id="local-6989586621681496296"><span class="annot"><span class="annottext">Match Term
</span><a href="#local-6989586621681496296"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681496297"><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621681496297"><span class="hs-identifier hs-var">arg</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">DeBruijnPattern -&gt; Arg Term -&gt; m (Match Term, Arg Term)
forall (m :: * -&gt; *).
MonadMatch m =&gt;
DeBruijnPattern -&gt; Arg Term -&gt; m (Match Term, Arg Term)
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchPattern"><span class="hs-identifier hs-var">matchPattern</span></a></span><span> </span><span class="annot"><span class="annottext">DeBruijnPattern
</span><a href="#local-6989586621681496289"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(DeBruijnPattern -&gt; Term) -&gt; Arg DeBruijnPattern -&gt; Arg Term
forall a b. (a -&gt; b) -&gt; Arg a -&gt; Arg b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">DeBruijnPattern -&gt; Term
</span><a href="Agda.Syntax.Internal.Pattern.html#patternToTerm"><span class="hs-identifier hs-var">patternToTerm</span></a></span><span> </span><span class="annot"><span class="annottext">Arg DeBruijnPattern
</span><a href="#local-6989586621681496290"><span class="hs-identifier hs-var">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-340"></span><span>        </span><span class="annot"><span class="annottext">Match DeBruijnPattern -&gt; m (Match DeBruijnPattern)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Match DeBruijnPattern -&gt; m (Match DeBruijnPattern))
-&gt; Match DeBruijnPattern -&gt; m (Match DeBruijnPattern)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Term -&gt; DeBruijnPattern) -&gt; Match Term -&gt; Match DeBruijnPattern
forall a b. (a -&gt; b) -&gt; Match a -&gt; Match b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">PatternInfo -&gt; Term -&gt; DeBruijnPattern
forall x. PatternInfo -&gt; Term -&gt; Pattern' x
</span><a href="Agda.Syntax.Internal.html#DotP"><span class="hs-identifier hs-var">DotP</span></a></span><span> </span><span class="annot"><span class="annottext">PatternInfo
</span><a href="Agda.Syntax.Internal.html#defaultPatternInfo"><span class="hs-identifier hs-var">defaultPatternInfo</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Match Term
</span><a href="#local-6989586621681496296"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-341"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">DeBruijnPattern
</span><a href="#local-6989586621681496289"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-342"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#ProjP"><span class="hs-identifier hs-type">ProjP</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match DeBruijnPattern)
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span>
</span><span id="line-343"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#IApplyP"><span class="hs-identifier hs-type">IApplyP</span></a></span><span> </span><span class="annot"><span class="annottext">PatternInfo
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681496299"><span class="annot"><span class="annottext">DBPatVar
</span><a href="#local-6989586621681496299"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">DBPatVar -&gt; m (Match DeBruijnPattern)
</span><a href="#local-6989586621681496293"><span class="hs-identifier hs-var">varMatch</span></a></span><span> </span><span class="annot"><span class="annottext">DBPatVar
</span><a href="#local-6989586621681496299"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-344"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#VarP"><span class="hs-identifier hs-type">VarP</span></a></span><span> </span><span class="annot"><span class="annottext">PatternInfo
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681496300"><span class="annot"><span class="annottext">DBPatVar
</span><a href="#local-6989586621681496300"><span class="hs-identifier hs-var">x</span></a></span></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">DBPatVar -&gt; m (Match DeBruijnPattern)
</span><a href="#local-6989586621681496293"><span class="hs-identifier hs-var">varMatch</span></a></span><span> </span><span class="annot"><span class="annottext">DBPatVar
</span><a href="#local-6989586621681496300"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-345"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#DotP"><span class="hs-identifier hs-type">DotP</span></a></span><span> </span><span class="annot"><span class="annottext">PatternInfo
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Match DeBruijnPattern -&gt; m (Match DeBruijnPattern)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Match DeBruijnPattern -&gt; m (Match DeBruijnPattern))
-&gt; Match DeBruijnPattern -&gt; m (Match DeBruijnPattern)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Simplification
-&gt; IntMap (Arg DeBruijnPattern) -&gt; Match DeBruijnPattern
forall a. Simplification -&gt; IntMap (Arg a) -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#Yes"><span class="hs-identifier hs-var">Yes</span></a></span><span> </span><span class="annot"><span class="annottext">Simplification
</span><a href="Agda.TypeChecking.Monad.Base.html#NoSimplification"><span class="hs-identifier hs-var">NoSimplification</span></a></span><span> </span><span class="annot"><span class="annottext">IntMap (Arg DeBruijnPattern)
forall a. Null a =&gt; a
</span><a href="Agda.Utils.Null.html#empty"><span class="hs-identifier hs-var">empty</span></a></span><span>
</span><span id="line-346"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#LitP"><span class="hs-identifier hs-type">LitP</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match DeBruijnPattern)
</span><a href="#local-6989586621681496295"><span class="hs-identifier hs-var">termMatch</span></a></span><span> </span><span class="hs-comment">-- Literal patterns bind no variables so we can fall back to the Term version.</span><span>
</span><span id="line-347"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#DefP"><span class="hs-identifier hs-type">DefP</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match DeBruijnPattern)
</span><a href="#local-6989586621681496295"><span class="hs-identifier hs-var">termMatch</span></a></span><span>
</span><span id="line-348"></span><span>
</span><span id="line-349"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#ConP"><span class="hs-identifier hs-type">ConP</span></a></span><span> </span><span id="local-6989586621681496301"><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621681496301"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621681496302"><span class="annot"><span class="annottext">ConPatternInfo
</span><a href="#local-6989586621681496302"><span class="hs-identifier hs-var">cpi</span></a></span></span><span> </span><span id="local-6989586621681496303"><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621681496303"><span class="hs-identifier hs-var">ps</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-350"></span><span>      </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">DeBruijnPattern
</span><a href="#local-6989586621681496292"><span class="hs-identifier hs-var">q</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-351"></span><span>        </span><span class="annot"><a href="Agda.Syntax.Internal.html#ConP"><span class="hs-identifier hs-type">ConP</span></a></span><span> </span><span id="local-6989586621681496304"><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621681496304"><span class="hs-identifier hs-var">c'</span></a></span></span><span> </span><span class="annot"><span class="annottext">ConPatternInfo
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681496305"><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621681496305"><span class="hs-identifier hs-var">qs</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621681496301"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">ConHead -&gt; ConHead -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621681496304"><span class="hs-identifier hs-var">c'</span></a></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
-&gt; [Arg DeBruijnPattern] -&gt; m (Match DeBruijnPattern)
forall (m :: * -&gt; *).
MonadMatch m =&gt;
[NamedArg DeBruijnPattern]
-&gt; [Arg DeBruijnPattern] -&gt; m (Match DeBruijnPattern)
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchPatternsP"><span class="hs-identifier hs-var">matchPatternsP</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621681496303"><span class="hs-identifier hs-var">ps</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">(NamedArg DeBruijnPattern -&gt; Arg DeBruijnPattern)
-&gt; [NamedArg DeBruijnPattern] -&gt; [Arg DeBruijnPattern]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">((NamedArg DeBruijnPattern -&gt; Arg DeBruijnPattern)
 -&gt; [NamedArg DeBruijnPattern] -&gt; [Arg DeBruijnPattern])
-&gt; ((Named NamedName DeBruijnPattern -&gt; DeBruijnPattern)
    -&gt; NamedArg DeBruijnPattern -&gt; Arg DeBruijnPattern)
-&gt; (Named NamedName DeBruijnPattern -&gt; DeBruijnPattern)
-&gt; [NamedArg DeBruijnPattern]
-&gt; [Arg DeBruijnPattern]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(Named NamedName DeBruijnPattern -&gt; DeBruijnPattern)
-&gt; NamedArg DeBruijnPattern -&gt; Arg DeBruijnPattern
forall a b. (a -&gt; b) -&gt; Arg a -&gt; Arg b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Named NamedName DeBruijnPattern -&gt; DeBruijnPattern
forall name a. Named name a -&gt; a
</span><a href="Agda.Syntax.Common.html#namedThing"><span class="hs-identifier hs-var">namedThing</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621681496305"><span class="hs-identifier hs-var">qs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-352"></span><span>                     </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Match DeBruijnPattern -&gt; m (Match DeBruijnPattern)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Match DeBruijnPattern
forall a. Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span><span>
</span><span id="line-353"></span><span>        </span><span class="annot"><a href="Agda.Syntax.Internal.html#LitP"><span class="hs-identifier hs-type">LitP</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(DeBruijnPattern -&gt; DeBruijnPattern)
-&gt; Match DeBruijnPattern -&gt; Match DeBruijnPattern
forall a b. (a -&gt; b) -&gt; Match a -&gt; Match b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">DeBruijnPattern -&gt; DeBruijnPattern
forall {x} {a}. Pattern' x -&gt; Pattern' a
</span><a href="#local-6989586621681496308"><span class="hs-identifier hs-var">toLitP</span></a></span><span> </span><span class="annot"><span class="annottext">(Match DeBruijnPattern -&gt; Match DeBruijnPattern)
-&gt; m (Match DeBruijnPattern) -&gt; m (Match DeBruijnPattern)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">m (Match DeBruijnPattern)
</span><a href="#local-6989586621681496295"><span class="hs-identifier hs-var">termMatch</span></a></span><span>
</span><span id="line-354"></span><span>          </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621681496308"><span class="annot"><span class="annottext">toLitP :: Pattern' x -&gt; Pattern' a
</span><a href="#local-6989586621681496308"><span class="hs-identifier hs-var hs-var">toLitP</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#DotP"><span class="hs-identifier hs-type">DotP</span></a></span><span> </span><span class="annot"><span class="annottext">PatternInfo
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#Lit"><span class="hs-identifier hs-type">Lit</span></a></span><span> </span><span id="local-6989586621681496311"><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621681496311"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Literal -&gt; Pattern' a
forall a. Literal -&gt; Pattern' a
</span><a href="Agda.Syntax.Internal.html#litP"><span class="hs-identifier hs-var">litP</span></a></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621681496311"><span class="hs-identifier hs-var">l</span></a></span><span>   </span><span class="hs-comment">-- All bindings should be to literals</span><span>
</span><span id="line-355"></span><span>                </span><span class="annot"><a href="#local-6989586621681496308"><span class="hs-identifier hs-var">toLitP</span></a></span><span> </span><span class="annot"><span class="annottext">Pattern' x
</span><span class="hs-identifier">_</span></span><span>                </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pattern' a
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span>
</span><span id="line-356"></span><span>        </span><span class="annot"><span class="annottext">DeBruijnPattern
</span><span class="hs-identifier">_</span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match DeBruijnPattern)
</span><a href="#local-6989586621681496295"><span class="hs-identifier hs-var">termMatch</span></a></span><span>
</span><span id="line-357"></span><span>
</span><span id="line-358"></span><span id="local-6989586621681495604"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#matchPatternsP"><span class="hs-identifier hs-type">matchPatternsP</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#MonadMatch"><span class="hs-identifier hs-type">MonadMatch</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681495604"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-359"></span><span>               </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Common.html#NamedArg"><span class="hs-identifier hs-type">NamedArg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#DeBruijnPattern"><span class="hs-identifier hs-type">DeBruijnPattern</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-360"></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#DeBruijnPattern"><span class="hs-identifier hs-type">DeBruijnPattern</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-361"></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681495604"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#DeBruijnPattern"><span class="hs-identifier hs-type">DeBruijnPattern</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-362"></span><span id="matchPatternsP"><span class="annot"><span class="annottext">matchPatternsP :: forall (m :: * -&gt; *).
MonadMatch m =&gt;
[NamedArg DeBruijnPattern]
-&gt; [Arg DeBruijnPattern] -&gt; m (Match DeBruijnPattern)
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchPatternsP"><span class="hs-identifier hs-var hs-var">matchPatternsP</span></a></span></span><span> </span><span id="local-6989586621681496321"><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621681496321"><span class="hs-identifier hs-var">ps</span></a></span></span><span> </span><span id="local-6989586621681496322"><span class="annot"><span class="annottext">[Arg DeBruijnPattern]
</span><a href="#local-6989586621681496322"><span class="hs-identifier hs-var">qs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-363"></span><span>  </span><span class="annot"><span class="annottext">[Match DeBruijnPattern] -&gt; Match DeBruijnPattern
forall a. Monoid a =&gt; [a] -&gt; a
</span><span class="hs-identifier hs-var">mconcat</span></span><span> </span><span class="annot"><span class="annottext">([Match DeBruijnPattern] -&gt; Match DeBruijnPattern)
-&gt; m [Match DeBruijnPattern] -&gt; m (Match DeBruijnPattern)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">(DeBruijnPattern
 -&gt; Arg DeBruijnPattern -&gt; m (Match DeBruijnPattern))
-&gt; [DeBruijnPattern]
-&gt; [Arg DeBruijnPattern]
-&gt; m [Match DeBruijnPattern]
forall (m :: * -&gt; *) a b c.
Applicative m =&gt;
(a -&gt; b -&gt; m c) -&gt; [a] -&gt; [b] -&gt; m [c]
</span><span class="hs-identifier hs-var">zipWithM</span></span><span> </span><span class="annot"><span class="annottext">DeBruijnPattern -&gt; Arg DeBruijnPattern -&gt; m (Match DeBruijnPattern)
forall (m :: * -&gt; *).
MonadMatch m =&gt;
DeBruijnPattern -&gt; Arg DeBruijnPattern -&gt; m (Match DeBruijnPattern)
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchPatternP"><span class="hs-identifier hs-var">matchPatternP</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(NamedArg DeBruijnPattern -&gt; DeBruijnPattern)
-&gt; [NamedArg DeBruijnPattern] -&gt; [DeBruijnPattern]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">NamedArg DeBruijnPattern -&gt; DeBruijnPattern
forall a. NamedArg a -&gt; a
</span><a href="Agda.Syntax.Common.html#namedArg"><span class="hs-identifier hs-var">namedArg</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621681496321"><span class="hs-identifier hs-var">ps</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Arg DeBruijnPattern]
</span><a href="#local-6989586621681496322"><span class="hs-identifier hs-var">qs</span></a></span><span>
</span><span id="line-364"></span></pre></body></html>